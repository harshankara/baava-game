<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no, shrink-to-fit=no, viewport-fit=cover">
    <!-- Enhanced iOS Safari zoom prevention -->
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-touch-fullscreen" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Additional mobile support -->
    <meta name="msapplication-tap-highlight" content="no">
    <meta name="theme-color" content="#111111">
    <title>The Baava Game</title>
    
    <!-- Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-QBSK648PMQ"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-QBSK648PMQ');
    </script>
    
    <!-- Google Fonts - Press Start 2P for retro game feel -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        * {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
            touch-action: manipulation; /* Allows scrolling but disables double-tap zoom */
            -webkit-tap-highlight-color: transparent;
        }
        
        html {
            /* Prevent zoom on iOS Safari */
            -webkit-text-size-adjust: 100%;
            -ms-text-size-adjust: 100%;
            /* Disable double-tap zoom */
            touch-action: manipulation;
            /* Additional cross-browser support */
            -moz-text-size-adjust: 100%;
            text-size-adjust: 100%;
        }
        
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #111;
            font-family: 'Press Start 2P', cursive, Arial, sans-serif;
            color: white;
            /* Aggressive zoom prevention */
            touch-action: manipulation;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
            /* Additional iOS zoom prevention */
            -webkit-user-zoom: disabled;
            -webkit-text-size-adjust: none;
            -moz-text-size-adjust: none;
            -ms-text-size-adjust: none;
            text-size-adjust: none;
            /* Force fixed positioning */
            position: fixed;
            width: 100%;
            height: 100%;
            /* Prevent any zoom behavior */
            zoom: 1 !important;
            -ms-zoom: 1 !important;
            -webkit-transform: scale(1) !important;
            -moz-transform: scale(1) !important;
            transform: scale(1) !important;
        }
        
        #game {
            display: block;
            /* Aggressive canvas zoom prevention */
            touch-action: manipulation;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
            -webkit-user-zoom: disabled;
            /* Force fixed scaling */
            zoom: 1 !important;
            -ms-zoom: 1 !important;
            -webkit-transform: scale(1) !important;
            -moz-transform: scale(1) !important;
            transform: scale(1) !important;
            /* Additional prevention */
            -webkit-text-size-adjust: none;
            -moz-text-size-adjust: none;
            -ms-text-size-adjust: none;
            text-size-adjust: none;
            /* Prevent selection and context menu */
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            /* Block all interaction except controlled touches */
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: rgba(0,0,0,0);
        }
        
        .game-title {
            font-family: 'Press Start 2P', cursive;
            color: #FFD700; /* Gold color */
            text-shadow: 4px 4px 0px #000, -2px -2px 0px #8B4513;
            text-align: center;
            font-size: 28px;
        }
        
        .game-message {
            font-family: 'Press Start 2P', cursive;
            color: #FFFFFF;
            text-shadow: 2px 2px 0px #000;
            text-align: center;
            font-size: 16px;
            margin: 15px 0;
        }
        
        /* Ensure portrait orientation on mobile */
        @media screen and (max-width: 812px) and (orientation: landscape) {
            #rotation-message {
                display: flex !important;
            }
        }
        
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            touch-action: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
        }
        
        #game {
            display: block;
            width: 100%;
            height: 100%;
            touch-action: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        
        #mobileControls {
            position: fixed;
            bottom: 20px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            padding: 0 10%;
            z-index: 2147483646; /* Very high priority - container */
            pointer-events: none; /* Fixed: Allow touches to pass through to canvas */
        }
        
        #leftBtn {
            left: 10%;
            bottom: 20px;
        }
        
        #rightBtn {
            right: 10%;
            bottom: 20px;
        }
        
        .controlBtn {
            width: 80px; /* Reduced size for less visual obstruction */
            height: 80px;
            background-color: rgba(255, 255, 255, 0.2); /* Reduced opacity for less visual impact */
            border: 2px solid rgba(255, 255, 255, 0.3); /* Reduced border opacity */
            border-radius: 50%;
            position: absolute; /* Changed to absolute for better positioning control */
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation; /* Improved touch handling */
            pointer-events: auto; /* Fixed: Only the buttons themselves catch touches */
            /* Hide controls initially until game starts */
            display: none;
            /* Arrow styling - only applied when visible */
            color: white;
            font-size: 30px;
            font-weight: bold;
            align-items: center;
            justify-content: center;
            z-index: 2147483647; /* Maximum z-index value - absolute highest priority */
        }
        
        .controlBtn.visible {
            display: flex !important;
        }
        
        #leftBtn::before {
            content: 'â€¹';
            color: white;
            font-size: 40px;
            font-weight: bold;
        }
        
        #rightBtn::before {
            content: 'â€º';
            color: white;
            font-size: 40px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="game"></canvas>
        
        <!-- Background music -->
        <audio id="backgroundMusic" loop>
            <source src="artifacts/chiptune.wav" type="audio/wav">
        </audio>
        
        <div id="mobileControls">
            <div id="leftBtn" class="controlBtn"></div>
            <div id="rightBtn" class="controlBtn"></div>
        </div>
        
        <div id="rotation-message" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.9); color: white; flex-direction: column; align-items: center; justify-content: center; z-index: 1000;">
            <div style="text-align: center; padding: 20px;">
                <h2>Please Rotate Your Device</h2>
                <p>This game is designed to be played in portrait mode.</p>
                <div style="font-size: 40px; margin: 20px; transform: rotate(90deg);">ðŸ“±â†»</div>
            </div>
        </div>
    </div>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            console.log("Game starting...");
            
            // Detect mobile device
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            console.log("Is mobile device:", isMobile);
            
            // Canvas setup
            const canvas = document.getElementById('game');
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            
            // Enable pixelation
            ctx.imageSmoothingEnabled = false;  // Turn off anti-aliasing for pixelated look
            
            // Global variables
            let roadWidth = 0;
            let roadLeft = 0;
            let animationFrame = 0;
            let lightFlashTimer = 0;
            let lightState = false;
            let lastTime = 0;
            let gameState = 'start'; // start, playing, gameOver, rules
            let gameOverReason = "Baava ran out of kudi!"; // Default game over message
            
            // Houses - village style
            let houses = []; // Will be initialized after canvas is ready
            
            // Village objects (sprites from images)
            let villageObjects = []; // Will be initialized after canvas is ready
            
            // Set canvas size to container
            function resizeCanvas() {
                console.log("Resizing canvas...");
                const container = document.getElementById('game-container');
                canvas.width = container.clientWidth;
                canvas.height = container.clientHeight;
                
                // Hide all GIFs on resize since their positions need to be recalculated
                hideAllGifs();
                
                // Calculate road dimensions
                roadWidth = canvas.width * 0.75; // Increased road width
                roadLeft = (canvas.width - roadWidth) / 2;
                
                // Initialize houses with larger sizes and better positioning
                // Calculate house sizes based on screen size (larger than before)
                const houseSize1 = Math.min(6, Math.max(3, Math.floor(canvas.width / 200))); // Increased size
                const houseSize2 = Math.min(7, Math.max(4, Math.floor(canvas.width / 180))); // Increased size
                
                // Calculate safe positions ensuring houses stay on green patches
                const leftPatchWidth = Math.max(30, roadLeft * 0.5); 
                const rightPatchStart = roadLeft + roadWidth + 10;
                
                // We're no longer using traditional houses
                houses = [];
                
                // Scale factor for village objects (based on screen size)
                const baseScale = Math.min(0.5, Math.max(0.2, canvas.width / 1500));
                
                // Calculate equal spacing for objects
                const totalObjects = 3;  // petti, scooter2, house1 (re-enabled)
                const verticalSpacing = canvas.height / (totalObjects + 1);
                const rightPatchCenter = rightPatchStart + ((canvas.width - rightPatchStart) / 2);
                
                // Initialize village objects with proper positioning on the right side
                // Position them just to the right of the road facing inward (toward the road)
                const rightSideX = roadLeft + roadWidth + 5; // Position very close to the road
                
                // Define positions for continuous vertical movement with much greater spacing
                const positions = [
                    canvas.height * 1.6,    // Far bottom - well below screen
                    canvas.height * 1.0,    // Lower visible position (bottom of screen)
                    canvas.height * 0.3,    // Middle visible position (much more space from bottom)
                    canvas.height * -0.4    // Top position (far above screen to ensure big gaps)
                ];
                
                // Calculate left side position (similar distance from road but on the left)
                const leftSideX = roadLeft * 0.2; // Position close to the road on the left side
                
                villageObjects = [
                    // RIGHT SIDE OBJECTS
                    // First object: petti - start at the very bottom position
                    { 
                        type: 'petti',
                        x: roadLeft + roadWidth * 0.8, // On the right side of road
                        y: positions[0], // Far below screen initially
                        scale: 0.08, // Reduced size
                        side: 'right',
                        initialY: positions[0],
                        faceRoad: true,
                        rolling: false
                    },
                    // Second object: scooter2 - start at bottom visible position
                    { 
                        type: 'scooter2',
                        x: roadLeft + roadWidth * 0.98, // Moved further to the right
                        y: positions[1], // Lower visible position (bottom of screen)
                        scale: 0.075, // Increased size
                        side: 'right',
                        initialY: positions[1],
                        faceRoad: true,
                        rolling: false
                    },
                    // Third object: house1 - DISABLED (commented out)
                    /*{ 
                        type: 'house1',
                        x: roadLeft + roadWidth * 0.9, // On the right side of road
                        y: positions[2], // Middle position with more space from bottom
                        scale: 0.16,
                        side: 'right',
                        initialY: positions[2],
                        faceRoad: true,
                        rolling: false
                    },*/
                    
                    // LEFT SIDE OBJECTS
                    // Fourth object: tuktuk - start at a different position on left side
                    { 
                        type: 'tuktuk',
                        x: roadLeft * 0.002, // Back to original position
                        y: positions[1] - canvas.height * 0.3, // Offset from right side positions for variety
                        scale: 0.13, // Further increased size (was 0.11)
                        side: 'left',
                        initialY: positions[1] - canvas.height * 0.2,
                        faceRoad: false, // No need to flip, naturally faces right
                        rolling: false
                    },
                    // Fifth object: house1 - positioned on left side within green patch
                    { 
                        type: 'house1',
                        x: -30, // Moved further left, outside frame
                        y: positions[0] - canvas.height * 0.4, // Different offset for variety
                        scale: 0.18, // Reduced size significantly (was 0.16)
                        side: 'left',
                        initialY: positions[0] - canvas.height * 0.3,
                        faceRoad: false, // No need to flip, naturally faces right
                        rolling: false
                    }
                ];
                
                console.log('Road dimensions:', {roadLeft, roadWidth});
                console.log('Right side X position:', rightSideX);
                
                console.log(`Canvas size: ${canvas.width}x${canvas.height}`);
                console.log(`Village objects initialized: ${villageObjects.length}`);
            }
            
            // Image loading system
            const images = {};
            // Track animated GIF elements
            const gifElements = {};
            const imagesToLoad = [
                // Animated GIFs need special handling
                { name: 'baavaHappy', src: 'artifacts/baava-happy.GIF', isGif: true },
                { name: 'baavaNeutral', src: 'artifacts/baava-neutral.GIF', isGif: true },
                { name: 'baavaSad', src: 'artifacts/baava-sad.GIF', isGif: true },
                { name: 'baavaBottle', src: 'artifacts/baava-bottle.GIF', isGif: true },
                { name: 'baavaLeaf', src: 'artifacts/baava-leaf.GIF', isGif: true },
                { name: 'oldmonk', src: 'artifacts/oldmonk.PNG' },
                { name: 'leaves', src: 'artifacts/leaves.PNG' },
                { name: 'raviAnna', src: 'artifacts/ravi-anna.GIF', isGif: true },
                { name: 'char1', src: 'artifacts/char1.GIF', isGif: true },
                { name: 'char2', src: 'artifacts/char2.GIF', isGif: true },
                { name: 'char3', src: 'artifacts/char3.GIF', isGif: true },
                { name: 'char4', src: 'artifacts/char4.GIF', isGif: true },
                { name: 'char5', src: 'artifacts/char5.GIF', isGif: true },
                { name: 'guru', src: 'artifacts/guru.GIF', isGif: true },
                // Village objects
                { name: 'petti', src: 'artifacts/petti.PNG' },
                { name: 'scooter2', src: 'artifacts/scooter2.PNG' },
                { name: 'house1', src: 'artifacts/house1.PNG' }, // Re-enabled house1
                { name: 'tuktuk', src: 'artifacts/tuktuk.PNG' }
            ];
            
            // Player setup
            const player = {
                x: 0,
                y: 0,
                width: 100,   // Increased from 65 for better visibility
                height: 105,  // Increased from 70 for better visibility
                speed: 5,
                energy: 100,
                direction: 0,  // -1: left, 0: still, 1: right
                frameX: 0,
                frameCount: 4,
                frameTimer: 0,
                frameInterval: 100, // ms
                isHit: false,
                isHappy: false,
                isCollectingBottle: false,
                isCollectingLeaf: false,
                // Flashing effect when hit
                isFlashing: false,
                flashTimer: 0,
                flashDuration: 1000, // Flash for 1 second
                // 4-Lane system
                currentLane: 1, // 0, 1, 2, 3 (left to right)
                targetX: 0,
                isMoving: false
            };
            
            // Game variables
            let score = 0;
            let currentRound = 1;
            let roundStartTime = 0;
            let roundDuration = 15000; // 15 seconds per round as specified
            let guruSpawnedThisRound = 0;
            
            // Round transition notification
            let showRoundTransition = false;
            let roundTransitionStartTime = 0;
            let roundTransitionDuration = 2000; // Show for 2 seconds
            
            // Music control
            let musicEnabled = true;
            let backgroundMusic = null;
            
            const alcohols = [];
            const leaves = [];
            const enemies = [];
            
            // Helper function to check if a new object would overlap with existing objects
            function isPositionClear(x, y, width, height, buffer = 50) {
                // Check against alcohols
                for (let i = 0; i < alcohols.length; i++) {
                    if (Math.abs(alcohols[i].x - x) < (alcohols[i].width + width) / 2 + buffer &&
                        Math.abs(alcohols[i].y - y) < (alcohols[i].height + height) / 2 + buffer) {
                        return false;
                    }
                }
                
                // Check against leaves
                for (let i = 0; i < leaves.length; i++) {
                    if (Math.abs((leaves[i].x || 0) - x) < ((leaves[i].width || 40) + width) / 2 + buffer &&
                        Math.abs(leaves[i].y - y) < ((leaves[i].height || 40) + height) / 2 + buffer) {
                        return false;
                    }
                }
                
                // Check against enemies
                for (let i = 0; i < enemies.length; i++) {
                    if (Math.abs(enemies[i].x - x) < (enemies[i].width + width) / 2 + buffer &&
                        Math.abs(enemies[i].y - y) < (enemies[i].height + height) / 2 + buffer) {
                        return false;
                    }
                }
                
                return true;
            }
            
            // Game progression system - calculate spawn rates based on round
            function getCollectibleSpawnRate() {
                if (currentRound <= 5) return 0.01; // Same low rate for first 5 rounds
                // Rapid increase after round 5: exponential scaling
                const postRound5 = currentRound - 5;
                return Math.min(0.08, 0.018 + (postRound5 * 0.012)); // Dramatic increase
            }
            
            function getLeafSpawnRate() {
                if (currentRound <= 5) return 0.008; // Same low rate for first 5 rounds
                // Rapid increase after round 5: exponential scaling
                const postRound5 = currentRound - 5;
                return Math.min(0.06, 0.015 + (postRound5 * 0.008)); // Dramatic increase
            }
            
            // Difficulty Scaling System according to game rules
            
            function getEnemyCount() {
                // Enemy Count per Frame based on round
                if (currentRound <= 5) {
                    // Gradual increase for first 5 rounds
                    if (currentRound <= 3) return 2;        // Max 2 enemies at once
                    else return 3;   // Max 3 enemies rounds 4-5
                } else {
                    // Rapid increase after round 5
                    const postRound5 = currentRound - 5;
                    return Math.min(12, 4 + (postRound5 * 2)); // Dramatic scaling: 4, 6, 8, 10, 12...
                }
            }
            
            function getGuruCount() {
                if (currentRound <= 5) {
                    return Math.min(Math.floor((currentRound + 1) / 2), 2); // Max 2 gurus before round 5
                } else {
                    // Rapid guru increase after round 5
                    const postRound5 = currentRound - 5;
                    return Math.min(8, 3 + postRound5); // 3, 4, 5, 6, 7, 8...
                }
            }
            
            // Enemy Speed Scaling: enemySpeed = baseSpeed + (roundNumber * speedStep)
            function getEnemySpeed() {
                if (currentRound <= 5) {
                    // Gradual increase for first 5 rounds
                    const baseSpeed = 1.0;
                    const speedStep = 0.15; // Moderate increase per round
                    return baseSpeed + (currentRound * speedStep);
                } else {
                    // Rapid speed increase after round 5
                    const postRound5 = currentRound - 5;
                    const baseSpeed = 1.75; // Speed at round 5
                    const rapidStep = 0.4; // Much faster increase per round
                    return Math.min(8.0, baseSpeed + (postRound5 * rapidStep)); // Cap at very fast speed
                }
            }
            
            // Enemy Spawn Rate Scaling: spawnRate = baseRate + (roundNumber * rateStep)
            function getEnemySpawnRate() {
                if (currentRound <= 5) {
                    // Gradual increase for first 5 rounds
                    const baseRate = 0.008;
                    const rateStep = 0.002;
                    return baseRate + (currentRound * rateStep);
                } else {
                    // Rapid spawn rate increase after round 5
                    const postRound5 = currentRound - 5;
                    const baseRate = 0.018; // Rate at round 5
                    const rapidStep = 0.008; // Much faster increase per round
                    return Math.min(0.1, baseRate + (postRound5 * rapidStep)); // Very high spawn rate cap
                }
            }
            
            // Speed progression functions for collectibles
            function getObjectSpeed() {
                if (currentRound <= 5) {
                    // Gradual increase for first 5 rounds
                    const baseSpeed = 1.5;
                    const speedMultiplier = 1 + (currentRound - 1) * 0.1;
                    return baseSpeed * speedMultiplier;
                } else {
                    // Rapid object speed increase after round 5
                    const postRound5 = currentRound - 5;
                    const baseSpeed = 2.0; // Speed at round 5
                    const rapidMultiplier = 1 + (postRound5 * 0.3); // Much faster scaling
                    return Math.min(10.0, baseSpeed * rapidMultiplier); // Cap at very fast speed
                }
            }
            
            function getLeafSpeed() {
                const baseSpeed = 1.2;
                const speedMultiplier = 1 + (currentRound - 1) * 0.12;
                return baseSpeed * speedMultiplier;
            }
            
            // Round management
            function updateRound(currentTime) {
                if (roundStartTime === 0) {
                    roundStartTime = currentTime;
                }
                
                if (currentTime - roundStartTime >= roundDuration) {
                    // Advance to next round
                    currentRound++;
                    roundStartTime = currentTime;
                    guruSpawnedThisRound = 0;
                    
                    console.log(`Advanced to Round ${currentRound}`);
                }
            }
            
            // Function to update GIF element position to match canvas coordinates
            function updateGifPosition(imageKey, x, y, width, height) {
                const gif = gifElements[imageKey];
                if (!gif) return;
                
                // Convert canvas coordinates to page coordinates
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                
                // Calculate the scaled position and size
                const scaledX = x / scaleX + rect.left;
                const scaledY = y / scaleY + rect.top;
                const scaledWidth = width / scaleX;
                const scaledHeight = height / scaleY;
                
                // Update the GIF element
                gif.style.position = 'fixed';
                gif.style.left = `${scaledX}px`;
                gif.style.top = `${scaledY}px`;
                gif.style.width = `${scaledWidth}px`;
                gif.style.height = `${scaledHeight}px`;
                gif.style.visibility = 'visible';
                gif.style.zIndex = '1000'; // Make sure it's on top
            }
            
            // Hide all GIF elements when not in use
            function hideAllGifs() {
                for (const key in gifElements) {
                    if (gifElements[key]) {
                        gifElements[key].style.visibility = 'hidden';
                    }
                }
            }
            
            // Music control functions
            function initMusic() {
                backgroundMusic = document.getElementById('backgroundMusic');
                
                // Set initial volume
                backgroundMusic.volume = 0.3;
            }
            
            function toggleMusic() {
                musicEnabled = !musicEnabled;
                console.log('Music toggled:', musicEnabled); // Debug log
                
                // Apply music state immediately regardless of game state
                if (musicEnabled) {
                    playBackgroundMusic();
                } else {
                    stopBackgroundMusic();
                }
            }
            
            function playBackgroundMusic() {
                if (backgroundMusic && musicEnabled) {
                    // Only reset if not already playing
                    if (backgroundMusic.paused || backgroundMusic.ended) {
                        backgroundMusic.currentTime = 0;
                    }
                    backgroundMusic.play().catch(e => {
                        console.log('Could not play music:', e);
                    });
                }
            }
            
            function stopBackgroundMusic() {
                if (backgroundMusic) {
                    backgroundMusic.pause();
                }
            }
            
            // Initialize the game
            function init() {
                // Initialize music controls
                initMusic();
                
                // Show loading screen
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#fff';
                ctx.font = "24px 'Press Start 2P', monospace"; // Changed to Press Start 2P
                ctx.textAlign = 'center';
                ctx.fillText('Loading...', canvas.width/2, canvas.height/2);
                
                // Load images before starting the game
                loadImages(() => {
                    resizeCanvas();
                    
                    // Position player at bottom center
                    player.x = canvas.width / 2;
                    player.y = canvas.height - 150;
                    
                    // Start game loop
                    requestAnimationFrame(gameLoop);
                });
            }
            
            // Image loading function
            function loadImages(callback) {
                let imagesToLoadCount = imagesToLoad.length;
                console.log(`Loading ${imagesToLoadCount} images...`);
                
                // Create container for GIF elements if it doesn't exist
                let gifContainer = document.getElementById('gif-container');
                if (!gifContainer) {
                    gifContainer = document.createElement('div');
                    gifContainer.id = 'gif-container';
                    gifContainer.style.position = 'absolute';
                    gifContainer.style.top = '-9999px';
                    gifContainer.style.left = '-9999px';
                    gifContainer.style.visibility = 'hidden';
                    document.body.appendChild(gifContainer);
                }
                
                // Check if all images are loaded
                function onLoad() {
                    imagesToLoadCount--;
                    console.log(`Image loaded, ${imagesToLoadCount} remaining.`);
                    if (imagesToLoadCount === 0) {
                        console.log('All images loaded successfully!');
                        // Debug village object images specifically
                        console.log('Village object images loaded?');
                        console.log('petti:', !!images['petti']);
                        console.log('scooter2:', !!images['scooter2']);
                        console.log('house1:', !!images['house1']); // Re-enabled house1 debug
                        console.log('tuktuk:', !!images['tuktuk']);
                        console.log('guru:', !!images['guru']);
                        console.log('All image keys:', Object.keys(images));
                        console.log('GIF elements:', Object.keys(gifElements));
                        callback(); // All images loaded, proceed with game
                    }
                }
                
                // Start loading all images
                imagesToLoad.forEach(img => {
                    if (img.isGif) {
                        // For GIFs, create an actual img element in DOM
                        // This lets the browser animate the GIF naturally
                        const gifImg = document.createElement('img');
                        gifImg.onload = onLoad;
                        gifImg.onerror = function() {
                            console.error('Error loading GIF:', img.src, img.name);
                            onLoad(); // Continue even with error
                        };
                        gifImg.src = img.src;
                        gifImg.style.width = '100px';  // Default size
                        gifImg.style.height = '100px'; // Default size
                        
                        // Add to container and track
                        gifContainer.appendChild(gifImg);
                        gifElements[img.name] = gifImg;
                        
                        // Also create a static image for the canvas as fallback
                        const staticImg = new Image();
                        staticImg.src = img.src;
                        images[img.name] = staticImg;
                    } else {
                        // Regular image loading
                        const image = new Image();
                        image.onload = onLoad;
                        image.onerror = function() {
                            console.error('Error loading image:', img.src, img.name);
                            onLoad(); // Continue even with error
                        };
                        image.src = img.src;
                        images[img.name] = image;
                    }
                });
            }

            // Function to draw a simple lantern (avoiding complex effects)
            function drawLantern(x, y, size) {
                // Draw a simple square lantern instead of a round one
                const lanternSize = size * 3;
                
                // Lantern body
                ctx.fillStyle = '#FF6347'; // Tomato
                ctx.fillRect(x - lanternSize/2, y + size, lanternSize, lanternSize);
                
                // Lantern glow (inner part)
                ctx.fillStyle = '#FFD700'; // Gold
                ctx.fillRect(x - lanternSize/3, y + size + lanternSize/6, lanternSize*2/3, lanternSize*2/3);
                
                // Top cap
                ctx.fillStyle = '#8B4513'; // Brown
                ctx.fillRect(x - size, y, size*2, size);
                
                // Hanging string
                ctx.strokeStyle = '#D3D3D3';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x, y - size*2);
                ctx.stroke();
            }
            
            // Function to draw a simpler light
            function drawGlowingLight(x, y, size, color) {
                // Just draw a simple colored circle - no glow effects to avoid issues
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
                
                // Add a white center for a simple light effect
                ctx.fillStyle = '#FFFFFF';
                ctx.beginPath();
                ctx.arc(x, y, size/2, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Draw the scene with wedding decorations
            function drawScene() {
                const pixelSize = 4;  // Size of each "pixel" in our pixel art
                
                // Dark background (night)
                ctx.fillStyle = '#111111';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw grass on both sides of the road
                const baseGrassColor = '#1e8449';  // Darker green base
                const darkGrassColor = '#196f3d';  // Even darker green for texture
                
                // Left side grass
                ctx.fillStyle = baseGrassColor;
                ctx.fillRect(0, 0, roadLeft, canvas.height);
                
                // Right side grass
                ctx.fillRect(roadLeft + roadWidth, 0, canvas.width - (roadLeft + roadWidth), canvas.height);
                
                // Add enhanced grass texture with variety
                for (let x = 0; x < canvas.width; x += pixelSize * 2) {
                    for (let y = 0; y < canvas.height; y += pixelSize * 2) {
                        // Only draw on grass areas
                        if (x < roadLeft || x > roadLeft + roadWidth) {
                            // Create multiple texture patterns
                            const pattern = (x + y) % 21;
                            
                            // Dense grass texture
                            if (pattern < 3) {
                                ctx.fillStyle = darkGrassColor;
                                ctx.fillRect(x, y, pixelSize, pixelSize);
                            }
                            // Lighter grass highlights
                            else if (pattern === 5) {
                                ctx.fillStyle = '#239B56';
                                ctx.fillRect(x, y, pixelSize/2, pixelSize/2);
                            }
                            // Small bushes/vegetation
                            else if (pattern === 8) {
                                ctx.fillStyle = '#145A32';
                                ctx.fillRect(x, y, pixelSize * 1.5, pixelSize);
                            }
                            // Tiny flowers (occasional color spots)
                            else if (pattern === 15) {
                                ctx.fillStyle = '#E74C3C';
                                ctx.fillRect(x + pixelSize/2, y + pixelSize/2, pixelSize/3, pixelSize/3);
                            }
                            else if (pattern === 18) {
                                ctx.fillStyle = '#F39C12';
                                ctx.fillRect(x + pixelSize/3, y + pixelSize/4, pixelSize/4, pixelSize/4);
                            }
                        }
                    }
                }
                
                // Draw traditional Indian village houses on the sides
                const drawIndianHouse = (x, y, size, mirrored = false) => {
                    // House base colors
                    const wallColor = '#e8d8c3';      // Mud/clay color
                    const darkWallColor = '#c9b18c';  // Darker mud accent
                    const roofColor = '#873600';      // Deep red-brown roof
                    const doorColor = '#5d4037';      // Dark wooden door
                    
                    const width = size * 10;
                    const height = size * 8;
                    
                    // Wall/base of the house
                    ctx.fillStyle = wallColor;
                    ctx.fillRect(x, y, width, height);
                    
                    // Wall texture
                    ctx.fillStyle = darkWallColor;
                    for (let wx = 0; wx < width; wx += size) {
                        for (let wy = 0; wy < height; wy += size * 2) {
                            if ((wx + wy) % (size * 3) === 0) {
                                ctx.fillRect(x + wx, y + wy, size, size);
                            }
                        }
                    }
                    
                    // Triangular roof or sloped roof
                    ctx.fillStyle = roofColor;
                    ctx.beginPath();
                    if (mirrored) {
                        ctx.moveTo(x, y);
                        ctx.lineTo(x + width, y);
                        ctx.lineTo(x + width + size * 2, y - size * 3);
                        ctx.lineTo(x - size * 2, y - size * 3);
                    } else {
                        ctx.moveTo(x - size * 2, y);
                        ctx.lineTo(x + width + size * 2, y);
                        ctx.lineTo(x + width, y - size * 3);
                        ctx.lineTo(x, y - size * 3);
                    }
                    ctx.fill();
                    
                    // Door
                    ctx.fillStyle = doorColor;
                    const doorWidth = size * 3;
                    const doorHeight = size * 4;
                    ctx.fillRect(x + (width - doorWidth) / 2, y + height - doorHeight, doorWidth, doorHeight);
                    
                    // Window(s)
                    ctx.fillStyle = '#ecf0f1';  // Light color for windows
                    const windowSize = size * 2;
                    if (width > size * 7) {
                        // Two windows if house is wide enough
                        ctx.fillRect(x + size * 2, y + size * 2, windowSize, windowSize);
                        ctx.fillRect(x + width - size * 2 - windowSize, y + size * 2, windowSize, windowSize);
                    } else {
                        // One window for smaller houses
                        ctx.fillRect(x + (width - windowSize) / 2, y + size * 2, windowSize, windowSize);
                    }
                };
                
                // Houses have been removed for simplicity
                
                // Draw water well - common in Indian villages
                const drawWell = (x, y, size) => {
                    const wellColor = '#7f8c8d';      // Stone color
                    const darkWellColor = '#2c3e50';  // Darker stone
                    const ropeColor = '#8b4513';      // Rope color
                    const bucketColor = '#e74c3c';    // Bucket color
                    
                    const wellSize = size * 8;
                    
                    // Main well circle
                    ctx.fillStyle = wellColor;
                    ctx.beginPath();
                    ctx.arc(x + wellSize/2, y + wellSize/2, wellSize/2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Inner circle (water)
                    ctx.fillStyle = '#3498db'; // Water color
                    ctx.beginPath();
                    ctx.arc(x + wellSize/2, y + wellSize/2, wellSize/3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Wooden structure above well
                    ctx.fillStyle = darkWellColor;
                    ctx.fillRect(x, y - size * 6, wellSize, size * 2);  // Horizontal beam
                    ctx.fillRect(x, y - size * 6, size * 2, size * 6);  // Left post
                    ctx.fillRect(x + wellSize - size * 2, y - size * 6, size * 2, size * 6);  // Right post
                    
                    // Rope and bucket
                    ctx.fillStyle = ropeColor;
                    ctx.fillRect(x + wellSize/2, y - size * 6, size, size * 4);  // Rope
                    
                    ctx.fillStyle = bucketColor;
                    ctx.fillRect(x + wellSize/2 - size, y - size * 2, size * 2, size * 2);  // Bucket
                };
                
                // Draw a traditional banyan tree
                const drawBanyanTree = (x, y, size) => {
                    // Tree trunk
                    ctx.fillStyle = '#6d4c41'; // Brown trunk
                    ctx.fillRect(x - size * 2, y - size * 10, size * 4, size * 10);
                    
                    // Hanging roots
                    for (let i = 0; i < 5; i++) {
                        const rootX = x - size * 4 + (i * size * 2);
                        ctx.fillRect(rootX, y - size * 8, size, size * 4);
                    }
                    
                    // Foliage (canopy)
                    ctx.fillStyle = '#196f3d'; // Dark green foliage
                    for (let i = 0; i < 3; i++) {
                        const radius = size * 8 - (i * size);
                        ctx.beginPath();
                        ctx.arc(x, y - size * 10 - (i * size * 2), radius, 0, Math.PI * 2);
                        ctx.fill();
                    }
                };
                
                // Draw a small temple
                const drawTemple = (x, y, size) => {
                    // Base
                    ctx.fillStyle = '#d1ccc0'; // Temple stone color
                    ctx.fillRect(x, y - size * 4, size * 8, size * 4);
                    
                    // Steps
                    ctx.fillRect(x + size, y, size * 6, size);
                    
                    // Dome/Shikhara
                    ctx.fillStyle = '#ff9f43'; // Saffron/orange color
                    ctx.beginPath();
                    ctx.moveTo(x, y - size * 4);
                    ctx.lineTo(x + size * 8, y - size * 4);
                    ctx.lineTo(x + size * 4, y - size * 10);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Top ornament
                    ctx.fillStyle = '#f1c40f'; // Gold color
                    ctx.fillRect(x + size * 3.5, y - size * 11, size, size);
                    ctx.beginPath();
                    ctx.arc(x + size * 4, y - size * 12, size, 0, Math.PI * 2);
                    ctx.fill();
                };
                
                // Well and banyan tree have been removed for simplicity
                
                // Add some flowers and small plants to the grass around houses
                const flowerColors = ['#FFFFFF', '#f1c40f', '#e74c3c', '#9b59b6']; // white, yellow, red, purple
                
                // Draw flowers based on animation frame so they don't flicker
                const flowerSeed = Math.floor(animationFrame / 20) % 100;
                
                for (let i = 0; i < 25; i++) {
                    // Deterministic random position
                    const xPos = ((i * 37 + flowerSeed) % canvas.width);
                    const yPos = ((i * 23 + flowerSeed * 7) % canvas.height);
                    
                    // Only draw on grass areas
                    if (xPos < roadLeft - pixelSize*2 || xPos > roadLeft + roadWidth + pixelSize*2) {
                        // Pick a deterministic color based on position
                        const colorIndex = (i + flowerSeed) % flowerColors.length;
                        
                        // Draw a small flower or plant
                        ctx.fillStyle = flowerColors[colorIndex];
                        ctx.fillRect(xPos, yPos, pixelSize, pixelSize);
                        
                        // Some flowers have extra petals
                        if (i % 3 === 0) {
                            ctx.fillRect(xPos - pixelSize, yPos, pixelSize, pixelSize);
                            ctx.fillRect(xPos + pixelSize, yPos, pixelSize, pixelSize);
                        }
                    }
                }
                
                // Draw straight road with gradient effect
                const baseRoadColor = '#8B4513';  // Brown road color
                const darkMudColor = '#654321';   // Darker brown for texture
                const trackColor = '#704214';     // Track color
                
                // Create road gradient for depth effect
                const roadGradient = ctx.createLinearGradient(roadLeft, 0, roadLeft + roadWidth, 0);
                roadGradient.addColorStop(0, '#654321');    // Darker edges
                roadGradient.addColorStop(0.2, baseRoadColor);
                roadGradient.addColorStop(0.8, baseRoadColor);
                roadGradient.addColorStop(1, '#654321');    // Darker edges
                
                // Draw the main road with gradient
                ctx.fillStyle = roadGradient;
                ctx.fillRect(roadLeft, 0, roadWidth, canvas.height);
                
                // Add enhanced road texture
                for (let x = roadLeft; x < roadLeft + roadWidth; x += pixelSize * 3) {
                    for (let y = 0; y < canvas.height; y += pixelSize * 3) {
                        // Create a stable pattern based on position
                        if ((Math.floor(x/pixelSize) + Math.floor(y/pixelSize)) % 5 === 0) {
                            ctx.fillStyle = darkMudColor;
                            ctx.fillRect(x, y, pixelSize, pixelSize);
                        }
                        // Add occasional pebbles/stones
                        if ((Math.floor(x/pixelSize) + Math.floor(y/pixelSize)) % 13 === 0) {
                            ctx.fillStyle = '#8B7355';
                            ctx.fillRect(x, y, pixelSize/2, pixelSize/2);
                        }
                    }
                }
                
                // Add track marks (vehicle tire tracks)
                for (let y = Math.floor(animationFrame % (pixelSize * 10)); y < canvas.height; y += pixelSize * 10) {
                    ctx.fillStyle = trackColor;
                    ctx.fillRect(roadLeft + roadWidth/3, y, pixelSize * 2, pixelSize);
                    ctx.fillRect(roadLeft + roadWidth*2/3, y, pixelSize * 2, pixelSize);
                }
                
                // Draw the village objects BEFORE poles and wires to place them behind
                villageObjects.forEach((obj, index) => {
                    // Make sure the image is loaded
                    if (images[obj.type]) {
                        // Draw the sprite with proper scaling
                        const img = images[obj.type];
                        const width = img.width * obj.scale;
                        const height = img.height * obj.scale;
                        
                        // Apply minimal glow for all objects (both left and right side)
                        const glowRadius = Math.max(width, height) * 0.2; // Minimal glow radius
                        const gradient = ctx.createRadialGradient(
                            obj.x + width/2, obj.y + height/2, 0,
                            obj.x + width/2, obj.y + height/2, glowRadius
                        );
                        gradient.addColorStop(0, 'rgba(255, 255, 200, 0.05)'); // Very minimal glow
                        gradient.addColorStop(1, 'rgba(255, 255, 200, 0)');
                        
                        ctx.fillStyle = gradient;
                        ctx.fillRect(obj.x - glowRadius/2, obj.y - glowRadius/2, 
                                  width + glowRadius, height + glowRadius);
                        
                        // Draw the actual sprite, with proper orientation based on side
                        try {
                            // Objects on the right side facing the road need to be flipped
                            if (obj.side === 'right' && obj.faceRoad) {
                                // Save the current state
                                ctx.save();
                                
                                // Move to the position where we want to draw
                                ctx.translate(obj.x + width/2, obj.y + height/2);
                                
                                // Flip horizontally to face toward the road (left side)
                                ctx.scale(-1, 1);
                                
                                // Draw the image centered at origin (adjusted for the flip)
                                ctx.drawImage(
                                    img, 
                                    -width/2, 
                                    -height/2, 
                                    width, 
                                    height
                                );
                                
                                // Restore the context to its original state
                                ctx.restore();
                            } else {
                                // Draw normally without flipping
                                ctx.drawImage(
                                    img, 
                                    obj.x, 
                                    obj.y, 
                                    width, 
                                    height
                                );
                            }
                        } catch (err) {
                            console.error(`Error drawing ${obj.type}:`, err);
                        }
                        
                        // Debug text removed
                    } else {
                        console.warn(`Image not loaded for object type: ${obj.type}`);
                    }
                });
                
                // Add decorative poles along the road (Indian village fair style)
                const poleSpacing = 350; // Increased spacing for fewer poles (about 2 per frame)
                const poleWidth = pixelSize * 3; // Width of each pole
                const poleHeight = 120; // Height of each pole
                
                // Use modulo operation with NEGATIVE value to create upward movement effect
                // This makes poles move upward to match the player running forward
                const poleOffset = (-animationFrame % poleSpacing);
                
                // Draw poles on both sides of the road - adding poles above and below screen to ensure seamless appearance
                for (let y = poleOffset - poleSpacing; y < canvas.height + poleSpacing; y += poleSpacing) {
                    // Draw pole shadows first (cast towards right/road)
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)'; // Semi-transparent black shadow
                    const shadowOffsetX = pixelSize * 2;
                    const shadowOffsetY = pixelSize;
                    
                    // Left pole shadow
                    ctx.fillRect(roadLeft - poleWidth + shadowOffsetX, y + shadowOffsetY, poleWidth, poleHeight);
                    // Right pole shadow
                    ctx.fillRect(roadLeft + roadWidth + shadowOffsetX, y + shadowOffsetY, poleWidth, poleHeight);
                    
                    // Now draw the actual poles
                    ctx.fillStyle = '#8B4513'; // Brown wooden pole
                    ctx.fillRect(roadLeft - poleWidth, y, poleWidth, poleHeight);
                    
                    // Right side pole
                    ctx.fillRect(roadLeft + roadWidth, y, poleWidth, poleHeight);
                    
                    // Top decorative element for poles (like a lamp post) - with shadows
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)'; // Shadow for tops
                    ctx.fillRect(roadLeft - poleWidth - 5 + shadowOffsetX, y + shadowOffsetY, poleWidth + 10, 5);
                    ctx.fillRect(roadLeft + roadWidth - 5 + shadowOffsetX, y + shadowOffsetY, poleWidth + 10, 5);
                    
                    ctx.fillStyle = '#A0522D'; // Sienna color for top decoration
                    ctx.fillRect(roadLeft - poleWidth - 5, y, poleWidth + 10, 5); // Left pole top
                    ctx.fillRect(roadLeft + roadWidth - 5, y, poleWidth + 10, 5); // Right pole top
                }
                
                // Draw vertical serial lights along the poles (Indian fair style)
                ctx.strokeStyle = '#444444'; // Wire color
                ctx.lineWidth = 2;
                
                // Use the same pole offset calculated above - already set to move upward
                
                for (let y = poleOffset - poleSpacing; y < canvas.height + poleSpacing; y += poleSpacing) {
                    // Draw wires along each side of the road vertically connecting poles
                    const leftPoleX = roadLeft - poleWidth/2; // Updated to match new pole position
                    const rightPoleX = roadLeft + roadWidth + poleWidth/2; // Updated to match new pole position
                    const startY = y + 10; // Attach to pole top
                    const endY = y + poleSpacing; // Connect to next pole
                    
                    // Left side vertical wire
                    ctx.beginPath();
                    ctx.moveTo(leftPoleX, startY);
                    
                    // Create a curve with control points for a natural droop
                    const leftCp1y = startY + (endY - startY) * 0.33; // First control point
                    const leftCp2y = endY - (endY - startY) * 0.33; // Second control point
                    
                    // Draw the curved wire on left side
                    ctx.bezierCurveTo(leftPoleX + 15, leftCp1y, leftPoleX + 15, leftCp2y, leftPoleX, endY);
                    ctx.stroke();
                    
                    // Right side vertical wire - curves to the left like the left wire
                    ctx.beginPath();
                    ctx.moveTo(rightPoleX, startY);
                    
                    // Create a curve with control points for a natural droop
                    const rightCp1y = startY + (endY - startY) * 0.33; // First control point
                    const rightCp2y = endY - (endY - startY) * 0.33; // Second control point
                    
                    // Draw the curved wire on right side (curving to the left)
                    ctx.bezierCurveTo(rightPoleX - 15, rightCp1y, rightPoleX - 15, rightCp2y, rightPoleX, endY);
                    ctx.stroke();
                    
                    // Add flashing lights along the left wire
                    const numLights = 8; // Increased number of lights on each vertical wire (was 5)
                    const lightSize = 4;
                    const lightColors = ['#FFD700', '#FF6347', '#4169E1', '#32CD32', '#FF1493']; // Gold, tomato, blue, green, pink
                    
                    for (let i = 0; i < numLights; i++) {
                        const t = i / (numLights - 1); // Parameter along curve (0 to 1)
                        
                        // Calculate positions on the left side curve using the bezier formula
                        const leftLightX = (1-t)*(1-t)*(1-t)*leftPoleX + 
                                          3*(1-t)*(1-t)*t*(leftPoleX + 15) + 
                                          3*(1-t)*t*t*(leftPoleX + 15) + 
                                          t*t*t*leftPoleX;
                        
                        const leftLightY = (1-t)*(1-t)*(1-t)*startY + 
                                          3*(1-t)*(1-t)*t*leftCp1y + 
                                          3*(1-t)*t*t*leftCp2y + 
                                          t*t*t*endY;
                        
                        // Only draw the light if it's currently "on" based on the lightState and position
                        if (lightState || (i % 2 === 0)) { // Alternate pattern for flashing
                            const colorIndex = (i + Math.floor(animationFrame / 20)) % lightColors.length;
                            drawGlowingLight(leftLightX, leftLightY, lightSize, lightColors[colorIndex]);
                        }
                        
                        // Calculate positions on the right side curve using the bezier formula (matching the curve to the left)
                        const rightLightX = (1-t)*(1-t)*(1-t)*rightPoleX + 
                                           3*(1-t)*(1-t)*t*(rightPoleX - 15) + 
                                           3*(1-t)*t*t*(rightPoleX - 15) + 
                                           t*t*t*rightPoleX;
                        
                        const rightLightY = (1-t)*(1-t)*(1-t)*startY + 
                                           3*(1-t)*(1-t)*t*rightCp1y + 
                                           3*(1-t)*t*t*rightCp2y + 
                                           t*t*t*endY;
                        
                        // Only draw the light if it's currently "on" based on the lightState and position
                        if (lightState || (i % 2 === 0)) { // Alternate pattern for flashing
                            const colorIndex = ((i + 2) + Math.floor(animationFrame / 20)) % lightColors.length; // Offset color index for variety
                            drawGlowingLight(rightLightX, rightLightY, lightSize, lightColors[colorIndex]);
                        }
                    }
                }
                
                // Add horizontal serial wire lights connecting every pole across the road
                // Connect all poles horizontally since we reduced poles per frame
                const horizontalWireSpacing = poleSpacing; // Connect every pole (was poleSpacing * 3)
                const horizontalWireOffset = (-animationFrame % horizontalWireSpacing);
                
                for (let y = horizontalWireOffset; y < canvas.height; y += horizontalWireSpacing) {
                    // Only draw if the horizontal wire would be visible
                    if (y > -20 && y < canvas.height + 20) {
                        const leftPoleX = roadLeft - poleWidth/2; // Updated to match new pole position
                        const rightPoleX = roadLeft + roadWidth + poleWidth/2; // Updated to match new pole position
                        const wireY = y + 30; // Position near the top of poles but not at the very top
                        
                        // Draw the horizontal wire with a nice curve
                        ctx.beginPath();
                        ctx.moveTo(leftPoleX, wireY);
                        
                        // Calculate the curve control points
                        const midX = roadLeft + roadWidth/2;
                        const droopAmount = 50; // How much the wire droops in the middle
                        
                        // Draw a curved wire that droops in the middle
                        ctx.quadraticCurveTo(midX, wireY + droopAmount, rightPoleX, wireY);
                        ctx.stroke();
                        
                        // Add decorative lights along the horizontal wire
                        const numLights = 6; // Reduced horizontal lights (was 8)
                        const lightSize = 5;
                        const lightColors = ['#FFD700', '#FF6347', '#4169E1', '#32CD32', '#FF1493']; // Gold, tomato, blue, green, pink
                        
                        for (let i = 0; i < numLights; i++) {
                            const t = i / (numLights - 1);
                            
                            // Calculate position along the quadratic curve
                            const lightX = (1-t)*(1-t)*leftPoleX + 2*(1-t)*t*midX + t*t*rightPoleX;
                            const lightY = (1-t)*(1-t)*wireY + 2*(1-t)*t*(wireY + droopAmount) + t*t*wireY;
                            
                            // Only draw the light if it's currently "on" based on the lightState and position
                            if (lightState || (i % 2 === 0)) { // Alternate pattern for flashing
                                const colorIndex = (i + Math.floor(animationFrame / 15)) % lightColors.length;
                                drawGlowingLight(lightX, lightY, lightSize, lightColors[colorIndex]);
                            }
                        }
                    }
                }
                
                // Houses should be drawn BEFORE poles and wires (moving draw logic to earlier in the rendering pipeline)
                // We'll update the house positions here but not draw them yet
                houses.forEach(house => {
                    // Calculate house movement based on animation frame (moving upward)
                    // Move at half the speed of poles for parallax effect
                    const houseSpeed = 0.5; // Half the speed of poles for parallax
                    
                    // Calculate the actual y-position without the modulo yet
                    let adjustedY = house.initialY - (animationFrame * houseSpeed);
                    
                    // Get house height based on size (approximate)
                    const houseHeight = house.size * 12;
                    
                    // When a house moves completely off the top of the screen
                    // We need to wrap it back to below the screen to create seamless looping
                    // The modulo operation needs to account for the full cycle distance
                    const fullCycleHeight = canvas.height + houseHeight * 2;
                    
                    // Apply the wrap-around using modulo, then adjust back to the cycle range
                    adjustedY = adjustedY % fullCycleHeight;
                    if (adjustedY < -houseHeight) {
                        adjustedY += fullCycleHeight;
                    }
                    
                    // Store the updated position
                    house.y = adjustedY;
                });
            }
            
            // Helper function to draw pixelated elements (with less pixelation)
            function drawPixelRect(x, y, width, height, color, pixelSize = 2) {
                ctx.fillStyle = color;
                
                // Draw as a series of larger pixels
                for (let px = 0; px < width; px += pixelSize) {
                    for (let py = 0; py < height; py += pixelSize) {
                        const pixW = Math.min(pixelSize, width - px);
                        const pixH = Math.min(pixelSize, height - py);
                        ctx.fillRect(
                            Math.floor(x + px), 
                            Math.floor(y + py), 
                            Math.ceil(pixW), 
                            Math.ceil(pixH)
                        );
                    }
                }
            }
            
            // Draw the player character using sprites
            function drawPlayer() {
                ctx.save();
                ctx.translate(Math.floor(player.x), Math.floor(player.y));
                
                // Choose between neutral, happy and sad based on player state
                let imageKey = 'baavaNeutral'; // Default state is neutral
                
                if (player.isHit) {
                    imageKey = 'baavaSad'; // Use sad when hit by enemy
                } else if (player.isCollectingBottle) {
                    imageKey = 'baavaBottle'; // Use bottle when collecting bottles
                } else if (player.isCollectingLeaf) {
                    imageKey = 'baavaLeaf'; // Use leaf when collecting leaves
                } else if (player.isHappy) {
                    imageKey = 'baavaHappy'; // Use happy when collecting items (fallback)
                }
                
                // Get both static and animated versions
                let playerImage = images[imageKey];
                let playerGif = gifElements[imageKey];
                
                // Calculate running animation effects - vertical bobbing only when moving
                let runningEffect = 0;
                
                if (player.direction !== 0) {
                    // Apply running animation ONLY when moving (vertical bobbing only)
                    runningEffect = Math.sin(player.frameX * 0.5) * 3; // Vertical movement
                    // No tilting to keep consistent with enemies
                }
                
                // Position for HTML element-based GIFs
                const destX = player.x - player.width/2;
                const destY = player.y - player.height/2 + runningEffect;
                
                // Apply flashing effect
                if (player.isFlashing) {
                    // Create flashing effect by alternating opacity
                    const flashPhase = Math.floor((Date.now() - player.flashTimer) / 150) % 2; // Flash every 150ms
                    ctx.globalAlpha = flashPhase === 0 ? 0.3 : 1.0; // Alternate between dim and normal
                }
                
                // If we have a GIF element, position and show it
                if (playerGif && document.getElementById('gif-container')) {
                    // Position and size the GIF element where it should appear on canvas
                    updateGifPosition(imageKey, destX, destY, player.width, player.height);
                    
                    // Apply flashing to GIF element as well
                    if (player.isFlashing) {
                        const flashPhase = Math.floor((Date.now() - player.flashTimer) / 150) % 2;
                        playerGif.style.opacity = flashPhase === 0 ? '0.3' : '1.0';
                    } else {
                        playerGif.style.opacity = '1.0'; // Normal opacity when not flashing
                    }
                    
                    // Draw placeholder rectangle with low opacity to mark position
                    ctx.fillStyle = 'rgba(255,255,255,0.01)';  // Almost invisible placeholder
                    ctx.fillRect(-player.width/2, -player.height/2 + runningEffect, player.width, player.height);
                } 
                // Fallback to static image if no GIF element
                else if (playerImage && playerImage.complete) {
                    ctx.drawImage(
                        playerImage,
                        0, 0, // Source X, Y
                        playerImage.width, playerImage.height, // Source width, height
                        -player.width/2, -player.height/2 + runningEffect, // Dest X, Y with bounce effect
                        player.width, player.height // Dest width, height
                    );
                } else {
                    // Fallback if image isn't loaded
                    ctx.fillStyle = '#3498db';  // Blue
                    ctx.fillRect(-player.width/2, -player.height/2 + runningEffect, player.width, player.height);
                }
                
                // Reset alpha after flashing effect
                ctx.globalAlpha = 1.0;
                
                ctx.restore();
            }
            
            // Draw kudi meter (energy bar) with all UI elements
            function drawEnergyBar() {
                const barWidth = 200;
                const barHeight = 20;
                const x = 20;
                const y = 30;
                
                // Background of energy bar
                ctx.fillStyle = '#333';
                ctx.fillRect(x, y, barWidth, barHeight);
                
                // Energy level
                const energyWidth = (player.energy / 100) * barWidth;
                ctx.fillStyle = player.energy > 30 ? '#2ecc71' : '#e74c3c';
                ctx.fillRect(x, y, energyWidth, barHeight);
                
                // Border
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.strokeRect(x, y, barWidth, barHeight);
                
                // "Kudi Meter" text inside the bar - centered
                ctx.fillStyle = '#fff';
                ctx.font = "12px 'Press Start 2P', monospace";
                ctx.textAlign = 'center'; // Center the text
                ctx.fillText(`Kudi Meter: ${Math.floor(player.energy)}%`, x + barWidth/2, y + 16);
                ctx.textAlign = 'left'; // Reset to left align for other text
                
                // UI elements positioned next to Kudi meter (on the road area)
                const uiStartX = x + barWidth + 15; // Reduced spacing from 40 to 15 - much closer to meter
                
                // Score display - positioned next to Kudi meter
                ctx.fillStyle = '#fff';
                ctx.font = "14px 'Press Start 2P', monospace"; // Increased size for visibility
                ctx.textAlign = 'left';
                ctx.fillText(`Score: ${score}`, uiStartX, y + 5);
                
                // Round display (next to Score)
                ctx.fillStyle = '#fff';
                ctx.font = "14px 'Press Start 2P', monospace"; // Increased size for visibility
                ctx.textAlign = 'left';
                ctx.fillText(`Round: ${currentRound}`, uiStartX, y + 25);
                
                // Music toggle - SIMPLE BUTTON APPROACH
                const musicY = y + 45;
                ctx.fillStyle = '#fff';
                ctx.font = "12px 'Press Start 2P', monospace";
                ctx.textAlign = 'left';
                ctx.fillText('Music:', uiStartX, musicY);

                // Draw simple button
                const btnX = uiStartX + 75;
                const btnY = musicY - 18;
                const btnW = 50;
                const btnH = 20;
                
                // Button background - green for ON, red for OFF
                ctx.fillStyle = musicEnabled ? '#00aa00' : '#aa0000';
                ctx.fillRect(btnX, btnY, btnW, btnH);
                
                // Button border
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2; // Make border more visible
                ctx.strokeRect(btnX, btnY, btnW, btnH);
                
                // Button text
                ctx.fillStyle = '#ffffff';
                ctx.font = "10px 'Press Start 2P', monospace";
                ctx.textAlign = 'center';
                ctx.fillText(musicEnabled ? 'ON' : 'OFF', btnX + btnW/2, btnY + 14);
                
                // Store button bounds with generous padding
                window.musicButton = {
                    x: btnX - 15,
                    y: btnY - 10, 
                    width: btnW + 30,
                    height: btnH + 20
                };
            }
            
            // Draw round transition notification
            function drawRoundTransition(currentTime) {
                if (!showRoundTransition) return;
                
                // Check if transition period is over
                if (currentTime - roundTransitionStartTime >= roundTransitionDuration) {
                    showRoundTransition = false;
                    return;
                }
                
                // Calculate fade effect
                const elapsed = currentTime - roundTransitionStartTime;
                const fadeInTime = 300; // Fade in for 300ms
                const fadeOutTime = 500; // Fade out for last 500ms
                let alpha = 1;
                
                if (elapsed < fadeInTime) {
                    alpha = elapsed / fadeInTime;
                } else if (elapsed > roundTransitionDuration - fadeOutTime) {
                    alpha = (roundTransitionDuration - elapsed) / fadeOutTime;
                }
                
                // Draw semi-transparent background
                ctx.save();
                ctx.fillStyle = `rgba(0, 0, 0, ${alpha * 0.7})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw round text
                ctx.fillStyle = `rgba(255, 215, 0, ${alpha})`; // Gold color with fade
                ctx.font = "bold 48px 'Press Start 2P', monospace"; // Changed to Press Start 2P
                ctx.textAlign = 'center';
                ctx.fillText(`ROUNDU ${currentRound}`, canvas.width / 2, canvas.height / 2 - 20);
                
                // Draw difficulty indicator
                let difficultyText = '';
                if (currentRound === 1) difficultyText = 'Getting Started...';
                else if (currentRound === 2) difficultyText = 'Warming Up...';
                else if (currentRound >= 3 && currentRound <= 5) difficultyText = 'Things Heat Up!';
                else difficultyText = 'Maximum Chaos!';
                
                ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                ctx.font = "bold 24px 'Press Start 2P', monospace"; // Changed to Press Start 2P
                ctx.fillText(difficultyText, canvas.width / 2, canvas.height / 2 + 30);
                
                ctx.restore();
            }
            
            // Draw alcohol bottle
            function drawAlcohol(alcohol) {
                ctx.save();
                ctx.translate(alcohol.x, alcohol.y);
                
                // Draw the alcohol bottle sprite
                if (images.oldmonk && images.oldmonk.complete) {
                    ctx.drawImage(
                        images.oldmonk,
                        0, 0,
                        images.oldmonk.width, images.oldmonk.height,
                        -alcohol.width/2, -alcohol.height/2,
                        alcohol.width, alcohol.height
                    );
                } else {
                    // Fallback if image isn't loaded
                    const bottleWidth = 180;
                    const bottleHeight = 90;
                    
                    // Draw bottle - amber color for whiskey/rum
                    ctx.fillStyle = '#FF8C00';  // Amber
                    ctx.fillRect(-bottleWidth/2, -bottleHeight/2, bottleWidth, bottleHeight);
                    
                    // Bottle neck
                    ctx.fillStyle = '#A0522D';  // Brown
                    ctx.fillRect(-bottleWidth/4, -bottleHeight/2 - 10, bottleWidth/2, 10);
                    
                    // Bottle cap
                    ctx.fillStyle = '#4a4a4a';  // Dark gray
                    ctx.fillRect(-bottleWidth/6, -bottleHeight/2 - 15, bottleWidth/3, 5);
                }
                
                ctx.restore();
            }
            
            // Draw leaf obstacles
            function drawLeaf(leaf) {
                ctx.save();
                ctx.translate(leaf.x, leaf.y);
                
                // Draw the leaf sprite
                if (images.leaves && images.leaves.complete) {
                    ctx.drawImage(
                        images.leaves,
                        0, 0,
                        images.leaves.width, images.leaves.height,
                        -leaf.width/2, -leaf.height/2,
                        leaf.width, leaf.height
                    );
                } else {
                    // Fallback if image isn't loaded
                    ctx.fillStyle = '#27ae60';  // Green
                    
                    // Simple leaf shape
                    ctx.beginPath();
                    ctx.ellipse(0, 0, 15, 25, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Leaf stem
                    ctx.fillStyle = '#7f8c8d';
                    ctx.fillRect(-2, -30, 4, 10);
                }
                
                ctx.restore();
            }
            
            // Draw enemy characters
            function drawEnemy(enemy) {
                // Choose enemy sprite based on type
                let imageKey = enemy.type; // Use type as the key to find the right GIF or image
                
                // If we have a GIF element for this enemy type, position and show it
                if (gifElements[imageKey] && document.getElementById('gif-container')) {
                    // Calculate the position for the GIF element
                    const destX = enemy.x - enemy.width/2;
                    const destY = enemy.y - enemy.height/2;
                    
                    // Position and size the GIF element where it should appear on canvas
                    updateGifPosition(imageKey, destX, destY, enemy.width, enemy.height);
                    
                    // Draw placeholder rectangle with low opacity to mark position (optional)
                    ctx.save();
                    ctx.translate(enemy.x, enemy.y);
                    ctx.fillStyle = 'rgba(255,255,255,0.01)';  // Almost invisible placeholder
                    ctx.fillRect(-enemy.width/2, -enemy.height/2, enemy.width, enemy.height);
                    ctx.restore();
                } 
                // Fallback to static image if no GIF element
                else {
                    ctx.save();
                    ctx.translate(enemy.x, enemy.y);
                    
                    if (images[imageKey] && images[imageKey].complete) {
                        ctx.drawImage(
                            images[imageKey],
                            0, 0, // Source X, Y
                            images[imageKey].width, images[imageKey].height, // Source width, height
                            -enemy.width/2, -enemy.height/2, // Dest X, Y
                            enemy.width, enemy.height // Dest width, height
                        );
                    } else {
                        // Fallback if image isn't loaded
                        ctx.fillStyle = '#e74c3c';  // Red
                        ctx.fillRect(-enemy.width/2, -enemy.height/2, enemy.width, enemy.height);
                    }
                    
                    ctx.restore();
                }
            }
            
            // Update player position and state
            function updatePlayer(deltaTime) {
                // 4-Lane Movement System
                const laneWidth = roadWidth / 4;
                const lanes = [
                    roadLeft + laneWidth * 0.5,     // Lane 0 (leftmost)
                    roadLeft + laneWidth * 1.5,     // Lane 1
                    roadLeft + laneWidth * 2.5,     // Lane 2
                    roadLeft + laneWidth * 3.5      // Lane 3 (rightmost)
                ];
                
                // Set target position based on current lane
                player.targetX = lanes[player.currentLane];
                
                // Smoothly move to target position
                const moveSpeed = 12; // Fast lane switching
                if (Math.abs(player.x - player.targetX) > 2) {
                    if (player.x < player.targetX) {
                        player.x += moveSpeed;
                        player.direction = 1;
                        player.isMoving = true;
                    } else if (player.x > player.targetX) {
                        player.x -= moveSpeed;
                        player.direction = -1;
                        player.isMoving = true;
                    }
                } else {
                    player.x = player.targetX; // Snap to lane center
                    player.direction = 0;
                    player.isMoving = false;
                }
                
                // Update animation frame (used for movement bobbing only)
                player.frameTimer += deltaTime;
                if (player.frameTimer > player.frameInterval) {
                    player.frameTimer = 0;
                    player.frameX = (player.frameX + 1) % player.frameCount;
                }
                
                // Update flashing effect
                if (player.isFlashing) {
                    if (Date.now() - player.flashTimer > player.flashDuration) {
                        player.isFlashing = false; // Stop flashing after duration
                    }
                }
                
                // Update energy
                // Energy only decreases when hit by enemies, not over time
                
                if (player.energy <= 0 && gameState === 'playing') {
                    gameState = 'gameOver';
                    gameOverReason = "Baava ran out of kudi!";
                    stopBackgroundMusic(); // Stop music when game ends
                    
                    // Hide mobile controls on game over
                    if (isMobile) {
                        const leftBtn = document.getElementById('leftBtn');
                        const rightBtn = document.getElementById('rightBtn');
                        leftBtn.classList.remove('visible');
                        rightBtn.classList.remove('visible');
                    }
                    
                    console.log("Game Over - Out of kudi");
                }
            }
            
            // Unified collectible spawning system (50% leaves, 50% bottles)
            function spawnCollectibles() {
                if (Math.random() < getCollectibleSpawnRate()) {  // Dynamic spawn rate based on round
                    // Determine type: 50% chance for leaves, 50% for bottles
                    const isLeaf = Math.random() < 0.5;
                    
                    if (isLeaf) {
                        spawnLeaf();
                    } else {
                        spawnBottle();
                    }
                }
            }
            
            // Spawn alcohol bottles (50% of all collectibles)
            function spawnBottle() {
                const width = 90;
                const height = 60;
                
                // Try multiple times to find a clear position in a random lane
                for (let attempts = 0; attempts < 10; attempts++) {
                    // Use the same 4-lane system as player
                    const laneWidth = roadWidth / 4;
                    const lanes = [
                        roadLeft + laneWidth * 0.5,     // Lane 0 (leftmost)
                        roadLeft + laneWidth * 1.5,     // Lane 1
                        roadLeft + laneWidth * 2.5,     // Lane 2
                        roadLeft + laneWidth * 3.5      // Lane 3 (rightmost)
                    ];
                    
                    // Pick a random lane for bottle spawn
                    const randomLane = Math.floor(Math.random() * lanes.length);
                    const x = lanes[randomLane];
                    const y = -50;
                    
                    if (isPositionClear(x, y, width, height)) {
                        const alcohol = {
                            x: x,
                            y: y,
                            speed: getObjectSpeed() + Math.random() * 2,
                            width: width,
                            height: height
                        };
                        alcohols.push(alcohol);
                        break;
                    }
                }
            }
            
            // Spawn leaves (50% of all collectibles)
            function spawnLeaf() {
                const width = 70;
                const height = 50;
                
                // Try multiple times to find a clear position in a random lane
                for (let attempts = 0; attempts < 10; attempts++) {
                    // Use the same 4-lane system as player
                    const laneWidth = roadWidth / 4;
                    const lanes = [
                        roadLeft + laneWidth * 0.5,     // Lane 0 (leftmost)
                        roadLeft + laneWidth * 1.5,     // Lane 1
                        roadLeft + laneWidth * 2.5,     // Lane 2
                        roadLeft + laneWidth * 3.5      // Lane 3 (rightmost)
                    ];
                    
                    // Pick a random lane for leaf spawn
                    const randomLane = Math.floor(Math.random() * lanes.length);
                    const x = lanes[randomLane];
                    const y = -50;
                    
                    if (isPositionClear(x, y, width, height)) {
                        const leaf = {
                            x: x,
                            y: y,
                            speed: getObjectSpeed() + Math.random() * 2,
                            width: width,
                            height: height
                        };
                        leaves.push(leaf);
                        break;
                    }
                }
            }
            
            // Update alcohol bottles
            function updateAlcohols() {
                for (let i = alcohols.length - 1; i >= 0; i--) {
                    alcohols[i].y += alcohols[i].speed;
                    
                    // Keep alcohol within road boundaries
                    if (alcohols[i].x < roadLeft + alcohols[i].width/2) {
                        alcohols[i].x = roadLeft + alcohols[i].width/2;
                    }
                    if (alcohols[i].x > roadLeft + roadWidth - alcohols[i].width/2) {
                        alcohols[i].x = roadLeft + roadWidth - alcohols[i].width/2;
                    }
                    
                    // Check collision with player
                    if (
                        alcohols[i].y > player.y - player.height/2 && 
                        alcohols[i].y < player.y + player.height/2 && 
                        alcohols[i].x > player.x - player.width/2 && 
                        alcohols[i].x < player.x + player.width/2
                    ) {
                        // Player collected alcohol (bottle)
                        player.energy = Math.min(100, player.energy + 5);  // Restores +5% Energy
                        score += 20;  // Adds +20 points to score
                        player.isCollectingBottle = true; // Make player show bottle collection animation
                        
                        // Reset isCollectingBottle after a short delay
                        setTimeout(() => { player.isCollectingBottle = false; }, 1000);
                        
                        alcohols.splice(i, 1);
                        continue;
                    }
                    
                    // Remove if off screen
                    if (alcohols[i].y > canvas.height + 50) {
                        alcohols.splice(i, 1);
                    }
                }
            }
            
            // Update leaf obstacles
            function updateLeaves() {
                for (let i = leaves.length - 1; i >= 0; i--) {
                    leaves[i].y += leaves[i].speed;
                    leaves[i].rotation += leaves[i].rotationSpeed;
                    
                    // Keep leaves within road boundaries
                    if (leaves[i].x < roadLeft + leaves[i].width/2) {
                        leaves[i].x = roadLeft + leaves[i].width/2;
                    }
                    if (leaves[i].x > roadLeft + roadWidth - leaves[i].width/2) {
                        leaves[i].x = roadLeft + roadWidth - leaves[i].width/2;
                    }
                    
                    // Check collision with player
                    if (
                        leaves[i].y > player.y - player.height/2 && 
                        leaves[i].y < player.y + player.height/2 && 
                        leaves[i].x > player.x - player.width/2 && 
                        leaves[i].x < player.x + player.width/2
                    ) {
                        // Player collected leaf
                        player.energy = Math.min(100, player.energy + 2);  // Restores +2% Energy
                        score += 10;  // Adds +10 points to score
                        player.isCollectingLeaf = true; // Make player show leaf collection animation
                        
                        // Reset isCollectingLeaf after a short delay
                        setTimeout(() => { player.isCollectingLeaf = false; }, 1000);
                        
                        leaves.splice(i, 1);
                        continue;
                    }
                    
                    // Remove if off screen
                    if (leaves[i].y > canvas.height + 50) {
                        leaves.splice(i, 1);
                    }
                }
            }
            
            // Spawn enemy characters
            // Define different enemy types
            const enemyTypes = [
                { name: 'raviAnna', type: 'raviAnna', speed: 1.2, width: 85, height: 110 }, // Increased height for Ravi Anna
                { name: 'char1', type: 'char1', speed: 1.3, width: 85, height: 90 }, // Reduced from player size
                { name: 'char2', type: 'char2', speed: 1.4, width: 85, height: 90 }, // Reduced from player size
                { name: 'char3', type: 'char3', speed: 1.3, width: 85, height: 90 }, // Reduced from player size
                { name: 'char4', type: 'char4', speed: 1.35, width: 85, height: 90 }, // Reduced from player size
                { name: 'char5', type: 'char5', speed: 1.25, width: 85, height: 90 }, // Reduced from player size
                { name: 'Guru', type: 'guru', speed: 1.6, width: 85, height: 90, isDeadly: false } // Reduced from player size
            ];
            
            let lastEnemyTypeIndex = -1; // Track current position in enemy spawn order
            
            function spawnEnemies() {
                // Ensure enemies don't spawn too early - must wait at least 5 seconds AND collectibles must come first
                const gameRunTime = roundStartTime > 0 ? (Date.now() - roundStartTime) : 0;
                const minimumDelay = 5000; // 5 seconds minimum before any enemies
                
                // Check if minimum time has passed
                if (gameRunTime < minimumDelay) {
                    return; // Too early for enemies
                }
                
                // Additional condition: At least one collectible must have spawned before enemies can appear
                const hasCollectiblesSpawned = (alcohols.length > 0 || leaves.length > 0);
                
                // Also ensure the first collectible has had time to move down a bit (so player can see it)
                const firstCollectibleNearBottom = 
                    (alcohols.length > 0 && alcohols[0].y > canvas.height * 0.3) || // Reduced from 0.7 to 0.3 - less strict
                    (leaves.length > 0 && leaves[0].y > canvas.height * 0.3) || // Reduced from 0.7 to 0.3 - less strict
                    (alcohols.length === 0 && leaves.length === 0 && gameRunTime > 8000); // Fallback after 8 seconds
                
                // Both conditions must be met: time passed AND collectibles present/visible
                if (!hasCollectiblesSpawned || !firstCollectibleNearBottom) {
                    return; // Collectibles must come first and be visible
                }
                
                // Check current enemy counts on screen
                const currentEnemyCount = enemies.filter(e => e.type !== 'guru').length;
                const currentGuruCount = enemies.filter(e => e.type === 'guru').length;
                
                // Get maximum allowed enemies for current round
                const maxEnemies = getEnemyCount();
                const maxGurus = getGuruCount();
                
                // Don't spawn if we already have enough enemies for this round
                if (currentEnemyCount >= maxEnemies && currentGuruCount >= maxGurus) {
                    return;
                }
                
                // Use the new difficulty-scaled spawn rate
                if (Math.random() < getEnemySpawnRate()) {
                    let typeIndex;
                    
                    // Check if we can spawn more enemies (regular + guru combined)
                    const totalCurrentEnemies = enemies.length;
                    const maxTotalEnemies = getEnemyCount() + getGuruCount();
                    
                    if (totalCurrentEnemies < maxTotalEnemies) {
                        // Spawn enemies in sequential order: Ravi Anna â†’ Char1 â†’ Char2 â†’ Char3 â†’ Char4 â†’ Char5 â†’ Guru â†’ repeat
                        lastEnemyTypeIndex = (lastEnemyTypeIndex + 1) % enemyTypes.length; // Include guru, cycle through all 0-6
                        typeIndex = lastEnemyTypeIndex;
                    } else {
                        return; // Can't spawn any more enemies this round
                    }
                    
                    // lastEnemyTypeIndex is already set above for sequential spawning
                    const enemyType = enemyTypes[typeIndex];
                    
                    // Try multiple times to find a clear position in a random lane
                    for (let attempts = 0; attempts < 10; attempts++) {
                        // Use the same 4-lane system as player
                        const laneWidth = roadWidth / 4;
                        const lanes = [
                            roadLeft + laneWidth * 0.5,     // Lane 0 (leftmost)
                            roadLeft + laneWidth * 1.5,     // Lane 1
                            roadLeft + laneWidth * 2.5,     // Lane 2
                            roadLeft + laneWidth * 3.5      // Lane 3 (rightmost)
                        ];
                        
                        // Pick a random lane for enemy spawn
                        const randomLane = Math.floor(Math.random() * lanes.length);
                        const x = lanes[randomLane];
                        const y = -50;
                        
                        if (isPositionClear(x, y, enemyType.width, enemyType.height)) {
                            const enemy = {
                                x: x,
                                y: y,
                                speed: getEnemySpeed(),
                                type: enemyType.type,
                                width: enemyType.width,
                                height: enemyType.height,
                                isDeadly: enemyType.isDeadly || false
                            };
                            enemies.push(enemy);
                            break;
                        }
                    }
                }
            }
            
            // Update enemy characters
            function updateEnemies() {
                for (let i = enemies.length - 1; i >= 0; i--) {
                    enemies[i].y += enemies[i].speed;
                    
                    // Keep enemies within road boundaries
                    if (enemies[i].x < roadLeft + enemies[i].width/2) {
                        enemies[i].x = roadLeft + enemies[i].width/2;
                    }
                    if (enemies[i].x > roadLeft + roadWidth - enemies[i].width/2) {
                        enemies[i].x = roadLeft + roadWidth - enemies[i].width/2;
                    }
                    
                    // Check collision with player
                    if (
                        enemies[i].y > player.y - player.height/2 && 
                        enemies[i].y < player.y + player.height/2 && 
                        enemies[i].x > player.x - player.width/2 && 
                        enemies[i].x < player.x + player.width/2
                    ) {
                        // Debug logging for collision
                        console.log(`Collision with ${enemies[i].type}, isDeadly: ${enemies[i].isDeadly}`);
                        
                        // Check if it's the deadly guru character (should not happen now)
                        if (enemies[i].isDeadly) {
                            // Game over immediately if colliding with guru
                            gameState = 'gameOver';
                            gameOverReason = "Guru caught you!";
                            stopBackgroundMusic(); // Stop music when game ends
                            
                            // Hide mobile controls on game over
                            if (isMobile) {
                                const leftBtn = document.getElementById('leftBtn');
                                const rightBtn = document.getElementById('rightBtn');
                                leftBtn.classList.remove('visible');
                                rightBtn.classList.remove('visible');
                            }
                            
                            enemies.splice(i, 1);
                            continue;
                        } else {
                            // Player hit regular enemy - damage based on enemy type
                            let damage = 35; // Default damage for most enemies
                            if (enemies[i].type === 'guru' || enemies[i].type === 'raviAnna') {
                                damage = 50; // Guru and Ravi Anna do -50% Energy
                            }
                            console.log(`Taking ${damage} damage from ${enemies[i].type}. Energy: ${player.energy} -> ${Math.max(0, player.energy - damage)}`);
                            player.energy = Math.max(0, player.energy - damage);
                            player.isHit = true;
                            
                            // Start flashing effect
                            player.isFlashing = true;
                            player.flashTimer = Date.now();
                            
                            // Reset isHit after a short delay
                            setTimeout(() => { player.isHit = false; }, 1000);
                            
                            enemies.splice(i, 1);
                            continue;
                        }
                    }
                    
                    // Remove if off screen
                    if (enemies[i].y > canvas.height + 50) {
                        enemies.splice(i, 1);
                    }
                }
            }
            
            // LED Dotted Font Function
            function drawLEDText(text, x, y, size, flashOn) {
                const dotSize = size / 8; // Size of each LED dot
                const spacing = size / 6; // Spacing between dots
                const letterSpacing = size * 0.8; // Spacing between letters
                
                // LED colors
                const onColor = flashOn ? '#00FF00' : '#004400';
                const glowColor = flashOn ? '#88FF88' : '#002200';
                
                let currentX = x - (text.length * letterSpacing) / 2; // Center the text
                
                for (let i = 0; i < text.length; i++) {
                    const char = text[i];
                    if (char === ' ') {
                        currentX += letterSpacing;
                        continue;
                    }
                    
                    // Draw LED dots for each character in a 7x5 grid pattern
                    drawLEDCharacter(char, currentX, y, dotSize, spacing, onColor, glowColor, flashOn);
                    currentX += letterSpacing;
                }
            }
            
            function drawLEDCharacter(char, x, y, dotSize, spacing, color, glowColor, flashOn) {
                // Define 7x5 LED patterns for each character
                const patterns = {
                    'T': [
                        [1,1,1,1,1],
                        [0,0,1,0,0],
                        [0,0,1,0,0],
                        [0,0,1,0,0],
                        [0,0,1,0,0],
                        [0,0,1,0,0],
                        [0,0,1,0,0]
                    ],
                    'H': [
                        [1,0,0,0,1],
                        [1,0,0,0,1],
                        [1,0,0,0,1],
                        [1,1,1,1,1],
                        [1,0,0,0,1],
                        [1,0,0,0,1],
                        [1,0,0,0,1]
                    ],
                    'E': [
                        [1,1,1,1,1],
                        [1,0,0,0,0],
                        [1,0,0,0,0],
                        [1,1,1,1,0],
                        [1,0,0,0,0],
                        [1,0,0,0,0],
                        [1,1,1,1,1]
                    ],
                    'B': [
                        [1,1,1,1,0],
                        [1,0,0,0,1],
                        [1,0,0,0,1],
                        [1,1,1,1,0],
                        [1,0,0,0,1],
                        [1,0,0,0,1],
                        [1,1,1,1,0]
                    ],
                    'A': [
                        [0,1,1,1,0],
                        [1,0,0,0,1],
                        [1,0,0,0,1],
                        [1,1,1,1,1],
                        [1,0,0,0,1],
                        [1,0,0,0,1],
                        [1,0,0,0,1]
                    ],
                    'V': [
                        [1,0,0,0,1],
                        [1,0,0,0,1],
                        [1,0,0,0,1],
                        [1,0,0,0,1],
                        [1,0,0,0,1],
                        [0,1,0,1,0],
                        [0,0,1,0,0]
                    ],
                    'G': [
                        [0,1,1,1,1],
                        [1,0,0,0,0],
                        [1,0,0,0,0],
                        [1,0,1,1,1],
                        [1,0,0,0,1],
                        [1,0,0,0,1],
                        [0,1,1,1,0]
                    ],
                    'M': [
                        [1,0,0,0,1],
                        [1,1,0,1,1],
                        [1,0,1,0,1],
                        [1,0,0,0,1],
                        [1,0,0,0,1],
                        [1,0,0,0,1],
                        [1,0,0,0,1]
                    ]
                };
                
                const pattern = patterns[char] || patterns['A']; // Default to A if character not found
                
                for (let row = 0; row < pattern.length; row++) {
                    for (let col = 0; col < pattern[row].length; col++) {
                        if (pattern[row][col] === 1) {
                            const dotX = x + col * spacing;
                            const dotY = y + row * spacing;
                            
                            // Draw glow effect when flashing
                            if (flashOn) {
                                ctx.shadowColor = glowColor;
                                ctx.shadowBlur = dotSize;
                            }
                            
                            ctx.fillStyle = color;
                            ctx.beginPath();
                            ctx.arc(dotX, dotY, dotSize / 2, 0, Math.PI * 2);
                            ctx.fill();
                            
                            // Reset shadow
                            ctx.shadowBlur = 0;
                        }
                    }
                }
            }
            
            // Draw start screen
            function drawStartScreen() {
                // Darker tinted background
                const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                gradient.addColorStop(0, 'rgba(0, 0, 0, 0.7)'); // Increased black tint (was 0.3)
                gradient.addColorStop(1, 'rgba(20, 20, 20, 0.8)'); // Increased bottom tint (was 0.4)
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Calculate positions
                const centerX = canvas.width / 2;
                let currentY = canvas.height * 0.18; // Moved up from 25% to 18% (moved up by about 2 lines)
                
                ctx.textAlign = 'center';
                
                // Flashing/glowing effect for title
                const flashOn = Math.floor(Date.now() / 600) % 2 === 0; // Flash every 600ms
                const glowIntensity = flashOn ? 20 : 5;
                
                // "THE" - Smaller than BAAVA
                ctx.fillStyle = '#FFFFFF'; // White
                ctx.font = "40px 'Press Start 2P', monospace"; // Reduced from 48px to 40px
                ctx.shadowColor = flashOn ? '#00FFFF' : '#FFFFFF'; // Cyan glow when flashing
                ctx.shadowBlur = glowIntensity;
                ctx.fillText('THE', centerX, currentY);
                
                currentY += 70; // Spacing above BAAVA
                
                // "BAAVA" - Largest, properly centered without extra spaces
                ctx.fillStyle = '#FFFFFF'; // White
                ctx.font = "64px 'Press Start 2P', monospace";
                ctx.shadowColor = flashOn ? '#00FFFF' : '#FFFFFF'; // Cyan glow when flashing
                ctx.shadowBlur = glowIntensity;
                ctx.fillText('BAAVA', centerX, currentY); // Removed extra spaces for proper centering
                
                currentY += 70; // Equal spacing below BAAVA (same as above)
                
                // "GAME" - Smaller than BAAVA, same as THE
                ctx.fillStyle = '#FFFFFF'; // White
                ctx.font = "40px 'Press Start 2P', monospace"; // Reduced from 48px to 40px to match THE
                ctx.shadowColor = flashOn ? '#00FFFF' : '#FFFFFF'; // Cyan glow when flashing
                ctx.shadowBlur = glowIntensity;
                ctx.fillText('GAME', centerX, currentY);
                
                // Reset shadow for other text
                ctx.shadowBlur = 0;
                
                currentY += 75; // Reduced break to move help text up (was 100)
                
                // Subtitle - Help text (broken into multiple lines for better readability)
                ctx.fillStyle = '#CCCCCC'; // Light gray
                ctx.font = "15px 'Press Start 2P', cursive"; // Larger font for help lines
                ctx.fillText('Help Baava Navigate', centerX, currentY);

                currentY += 25; // Reduced spacing between lines

                ctx.fillText('Naveena\'s Beegru Oota', centerX, currentY);

                currentY += 25; // Reduced spacing between lines

                ctx.fillText('by collecting his', centerX, currentY);

                currentY += 25; // Reduced spacing between lines

                ctx.fillText('favourites!', centerX, currentY);

                currentY += 65; // Increased break before tap to start for line break (was 45)

                // Extra line break before Tap to Start
                currentY += 5; // Reduced spacing significantly (was 20, now much smaller)

                // Tap to start - slightly smaller, still red
                ctx.fillStyle = '#FF2222'; // Bright red
                ctx.font = "16px 'Press Start 2P', cursive";
                const tapToStartY = currentY; // Store position for click detection
                ctx.fillText('Tap to Start Play', centerX, currentY);

                currentY += 45; // Increased space after tap to start for line break (was 25)

                // Rules button - smaller, yellow
                ctx.fillStyle = '#FFD700'; // Gold/Yellow
                ctx.font = "14px 'Press Start 2P', cursive";
                const rulesY = currentY; // Store position for click detection
                ctx.fillText('Rules', centerX, currentY);

                // Store button positions globally for click detection
                window.buttonPositions = {
                    tapToStart: { x: centerX, y: tapToStartY },
                    rules: { x: centerX, y: rulesY }
                };

                currentY += 60; // Space after
                
                // Add extra line break before credit line
                currentY += 25; // Additional spacing for visual separation
                
                // Credit line at the bottom
                ctx.fillStyle = '#FFFFFF'; // White color for clean visibility (was #00FFFF)
                ctx.font = "8px 'Press Start 2P', cursive"; // Small font
                ctx.fillText('@harshankara', centerX, canvas.height - 95); // Moved up one more line from -75 to -95
            }
            
            // Draw game over screen
            function drawGameOverScreen() {
                // Create darker gradient background
                const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                gradient.addColorStop(0, 'rgba(20, 20, 50, 0.80)'); // Increased opacity (was 0.65)
                gradient.addColorStop(1, 'rgba(15, 15, 40, 0.85)'); // Increased opacity (was 0.70)
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Set text alignment for centered text
                ctx.textAlign = 'center';
                
                // Calculate positions for proper spacing
                const centerX = canvas.width / 2;
                let currentY = canvas.height / 2 - 160; // Moved up from -120 to -160 (moved up by about 2 lines)
                
                // Flashing and glow effect variables (same as home page)
                const time = Date.now();
                const flashOn = Math.floor(time / 400) % 2 === 0; // Flash every 400ms
                const glowIntensity = 15 + 10 * Math.sin(time / 300); // Pulsing glow
                
                // "BAAVA" - Small (reduced from 40px to 34px)
                ctx.fillStyle = '#FFFFFF'; // White
                ctx.font = "34px 'Press Start 2P', monospace";
                ctx.shadowColor = flashOn ? '#00FFFF' : '#FFFFFF'; // Cyan glow when flashing
                ctx.shadowBlur = glowIntensity;
                ctx.fillText('BAAVA', centerX, currentY);
                
                currentY += 70; // Equal spacing
                
                // "PUDCHA" - Biggest (reduced from 64px to 56px)
                ctx.fillStyle = '#FFFFFF'; // White
                ctx.font = "56px 'Press Start 2P', monospace";
                ctx.shadowColor = flashOn ? '#00FFFF' : '#FFFFFF'; // Cyan glow when flashing
                ctx.shadowBlur = glowIntensity;
                ctx.fillText('PUDCHA', centerX, currentY);
                
                currentY += 70; // Equal spacing
                
                // "MARRE!" - Small (reduced from 40px to 34px)
                ctx.fillStyle = '#FFFFFF'; // White
                ctx.font = "34px 'Press Start 2P', monospace";
                ctx.shadowColor = flashOn ? '#00FFFF' : '#FFFFFF'; // Cyan glow when flashing
                ctx.shadowBlur = glowIntensity;
                ctx.fillText('MARRE!', centerX, currentY);
                
                // Reset shadow for score and other text
                ctx.shadowBlur = 0;
                
                currentY += 80; // Larger break before score
                
                // "Your Score:" label
                ctx.fillStyle = '#FFFFFF';
                ctx.font = "18px 'Press Start 2P', monospace";
                ctx.fillText('Your Score:', centerX, currentY);
                
                currentY += 40; // Space between label and score
                
                // Score value in bright green
                ctx.fillStyle = '#00FF00'; // Bright green like an LED
                ctx.font = "32px 'Press Start 2P', monospace";
                ctx.fillText(`${score}`, centerX, currentY);
                
                currentY += 50; // Reduced space before fun message
                
                // Fun message - same as in rules popup
                ctx.fillStyle = '#FFD700'; // Gold
                ctx.font = "10px 'Press Start 2P', monospace"; // Increased from 8px to 10px
                ctx.fillText('Just for fun, made out of', centerX, currentY);
                
                currentY += 15; // Increased line spacing
                ctx.fillText('love for Su From So movie !', centerX, currentY);
                
                currentY += 50; // Added even more space after the message (extra line break)
                
                // "Tap to Start Play" without blinking effect
                ctx.fillStyle = '#FF2222'; // Bright red
                ctx.font = "18px 'Press Start 2P', monospace";
                ctx.fillText('Tap to Start Play', centerX, currentY);
                
                // Add extra line break before credit line
                currentY += 25; // Additional spacing for visual separation
                
                // Credit line at the bottom
                ctx.fillStyle = '#FFFFFF'; // White color for clean visibility
                ctx.font = "8px 'Press Start 2P', cursive"; // Small font
                ctx.fillText('@harshankara', centerX, canvas.height - 95); // Moved up one more line from -75 to -95
            }
            
            // Draw rules popup
            function drawRulesPopup() {
                // Darker semi-transparent background overlay
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)'; // Increased opacity (was 0.5)
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Popup background
                const popupWidth = canvas.width * 0.7; // Reduced from 0.9 to 0.7
                const popupHeight = canvas.height * 0.6; // Reduced from 0.75 to 0.6
                const popupX = (canvas.width - popupWidth) / 2;
                const popupY = (canvas.height - popupHeight) / 2;
                
                // Popup background with border
                ctx.fillStyle = '#1a1a2e'; // Dark blue
                ctx.fillRect(popupX, popupY, popupWidth, popupHeight);
                
                ctx.strokeStyle = '#FFD700'; // Gold border
                ctx.lineWidth = 3;
                ctx.strokeRect(popupX, popupY, popupWidth, popupHeight);
                
                // Set text alignment
                ctx.textAlign = 'center';
                
                const centerX = canvas.width / 2;
                let currentY = popupY + 40;
                
                // Title
                ctx.fillStyle = '#FFD700'; // Gold
                ctx.font = "20px 'Press Start 2P', monospace";
                ctx.fillText('GAME RULES', centerX, currentY);
                
                currentY += 50;
                
                // Collectibles section
                ctx.fillStyle = '#00FF00'; // Green
                ctx.font = "14px 'Press Start 2P', monospace";
                ctx.fillText('COLLECTIBLES', centerX, currentY);
                
                currentY += 35;
                ctx.fillStyle = '#FFFFFF'; // White
                ctx.font = "10px 'Press Start 2P', monospace"; // Even smaller font
                ctx.fillText('Bottle: +20pts +5% Energy', centerX, currentY);
                
                currentY += 25;
                ctx.fillText('Leaves: +10pts +2% Energy', centerX, currentY);
                
                currentY += 45;
                
                // Damage section
                ctx.fillStyle = '#FF4444'; // Red
                ctx.font = "14px 'Press Start 2P', monospace";
                ctx.fillText('DAMAGE', centerX, currentY);
                
                currentY += 35;
                ctx.fillStyle = '#FFFFFF'; // White
                ctx.font = "10px 'Press Start 2P', monospace"; // Consistent smaller font
                ctx.fillText('Guruji & Ravi Anna:', centerX, currentY);
                
                currentY += 20; // Smaller spacing
                ctx.fillText('-50% Energy', centerX, currentY);
                
                currentY += 30; // Space before next section
                ctx.fillText('Other Enemies:', centerX, currentY);
                
                currentY += 20; // Smaller spacing
                ctx.fillText('-30% Energy', centerX, currentY);
                
                currentY += 50; // Reduced spacing
                
                // Fun message - moved above close instruction
                ctx.fillStyle = '#FFD700'; // Gold
                ctx.font = "10px 'Press Start 2P', monospace"; // Increased from 8px to 10px
                ctx.fillText('Just for fun, made out of', centerX, currentY);
                
                currentY += 15; // Increased line spacing
                ctx.fillText('love for Su From So movie!', centerX, currentY);
                
                currentY += 25; // Reduced space after the message (less line break)
                
                // Close instruction - moved below
                ctx.fillStyle = '#FF2222'; // Red
                ctx.font = "12px 'Press Start 2P', monospace";
                ctx.fillText('Tap anywhere to close', centerX, currentY);
            }
            
            // Handle keyboard input - 4-Lane Movement
            function handleKeyDown(e) {
                if (gameState === 'playing') {
                    if (e.key === 'ArrowLeft' && player.currentLane > 0) {
                        player.currentLane--;
                        e.preventDefault();
                    } else if (e.key === 'ArrowRight' && player.currentLane < 3) {
                        player.currentLane++;
                        e.preventDefault();
                    }
                }
            }
            
            function handleKeyUp(e) {
                // No need to handle key up for discrete lane movement
            }
            
            // Handle touch input
            function setupMobileControls() {
                const leftBtn = document.getElementById('leftBtn');
                const rightBtn = document.getElementById('rightBtn');
                
                // Global document touch handler - highest priority, bypasses canvas interference
                document.addEventListener('touchstart', function(e) {
                    const touch = e.touches[0];
                    const touchX = touch.clientX;
                    const touchY = touch.clientY;
                    
                    console.log(`Touch at: ${touchX}, ${touchY}`);
                    
                    // FIRST PRIORITY: Check music button (works in all game states)
                    if (window.musicButton) {
                        const canvas = document.getElementById('game');
                        const rect = canvas.getBoundingClientRect();
                        const canvasX = touchX - rect.left;
                        const canvasY = touchY - rect.top;
                        
                        const btn = window.musicButton;
                        if (canvasX >= btn.x && canvasX <= btn.x + btn.width && 
                            canvasY >= btn.y && canvasY <= btn.y + btn.height) {
                            console.log('ðŸŽµ Music button touched via mobile handler!');
                            e.preventDefault();
                            e.stopPropagation();
                            toggleMusic();
                            return;
                        }
                    }
                    
                    // SECOND PRIORITY: Mobile controls (only during gameplay)
                    if (gameState !== 'playing') return;
                    
                    e.preventDefault();
                    e.stopPropagation();
                    
                    // Get button positions and dimensions
                    const leftBtnRect = leftBtn.getBoundingClientRect();
                    const rightBtnRect = rightBtn.getBoundingClientRect();
                    
                    console.log(`Touch at: ${touchX}, ${touchY}`);
                    // console.log(`Left button: ${leftBtnRect.left}-${leftBtnRect.right}, ${leftBtnRect.top}-${leftBtnRect.bottom}`);
                    // console.log(`Right button: ${rightBtnRect.left}-${rightBtnRect.right}, ${rightBtnRect.top}-${rightBtnRect.bottom}`);
                    
                    // Check if touch is within left button area
                    if (touchX >= leftBtnRect.left && touchX <= leftBtnRect.right &&
                        touchY >= leftBtnRect.top && touchY <= leftBtnRect.bottom) {
                        console.log('Left button touched!');
                        if (player.currentLane > 0) {
                            player.currentLane--;
                        }
                        return;
                    }
                    
                    // Check if touch is within right button area
                    if (touchX >= rightBtnRect.left && touchX <= rightBtnRect.right &&
                        touchY >= rightBtnRect.top && touchY <= rightBtnRect.bottom) {
                        console.log('Right button touched!');
                        if (player.currentLane < 3) {
                            player.currentLane++;
                        }
                        return;
                    }
                    
                }, { passive: false, capture: true }); // Use capture phase for highest priority
                
                // Fallback: Direct button event listeners (in case document handler fails)
                leftBtn.addEventListener('touchstart', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('Direct left button touch');
                    if (gameState === 'playing' && player.currentLane > 0) {
                        player.currentLane--;
                    }
                }, { passive: false });
                
                rightBtn.addEventListener('touchstart', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('Direct right button touch');
                    if (gameState === 'playing' && player.currentLane < 3) {
                        player.currentLane++;
                    }
                }, { passive: false });
            }
            
            // Start or restart the game
            function startGame() {
                if (gameState === 'start' || gameState === 'gameOver') {
                    // Reset game state
                    gameState = 'playing';
                    player.energy = 100;
                    score = 0;
                    
                    // Reset 4-lane player position
                    player.currentLane = 1; // Start in lane 1 (second from left)
                    player.direction = 0;
                    player.isMoving = false;
                    
                    // Reset round system
                    currentRound = 1;
                    roundStartTime = 0;
                    guruSpawnedThisRound = 0;
                    showRoundTransition = false;
                    roundTransitionStartTime = 0;
                    
                    // Clear arrays
                    alcohols.length = 0;
                    leaves.length = 0;
                    enemies.length = 0;
                    
                    // Show mobile controls during gameplay
                    if (isMobile) {
                        const leftBtn = document.getElementById('leftBtn');
                        const rightBtn = document.getElementById('rightBtn');
                        leftBtn.classList.add('visible');
                        rightBtn.classList.add('visible');
                    }
                    
                    // Start background music if enabled
                    playBackgroundMusic();
                }
            }
            
            // Update the village objects with continuous upward movement like the poles
            function updateVillageObjects() {
                // Define the speed at which objects move upward (slower than poles for parallax effect)
                const moveSpeed = 0.8; // Slightly faster speed to match the increased distances
                
                // Define fixed positions for the three visible positions with increased spacing
                // These are percentages of canvas height from the top
                const positions = [
                    canvas.height * 1.6,    // Far bottom - well below screen
                    canvas.height * 1.0,    // Lower visible position (bottom of screen)
                    canvas.height * 0.3,    // Middle visible position (much more space from bottom)
                    canvas.height * -0.4    // Top position (far above screen to ensure big gaps)
                ];
                
                // Get the height of the object's image for better reset position
                const getObjectHeight = (obj) => {
                    const img = images[obj.type];
                    return img ? img.height * obj.scale : 100;
                };
                
                // Update each object's position
                villageObjects.forEach((obj, index) => {
                    // Save initial X position if not already saved (for horizontal position)
                    if (!obj.initialX) {
                        obj.initialX = obj.x;
                    }
                    
                    // Move object up by moveSpeed
                    obj.y -= moveSpeed;
                    
                    // Get object height for proper reset point
                    const objHeight = getObjectHeight(obj);
                    
                    // If object moves completely above the screen, reset to below the screen
                    if (obj.y < -objHeight) { // Completely above top of screen
                        obj.y = canvas.height * 1.6; // Reset to the far bottom position
                        
                        // Make sure objects maintain proper spacing when they reappear
                        // Check for any objects already in the bottom area on the same side
                        const bottomObjects = villageObjects.filter(o => 
                            o !== obj && o.side === obj.side && 
                            o.y > canvas.height && o.y < canvas.height * 2);
                            
                        if (bottomObjects.length > 0) {
                            // If there's already an object in the bottom area on the same side, move this one further down
                            obj.y = canvas.height * 2.0; // Place even further below screen
                        }
                    }
                    
                    // Small horizontal sway for visual interest
                    const frequencyOffset = 60 + (index * 15); // Different frequency for each object
                    const horizontalOffset = Math.cos(animationFrame / frequencyOffset) * 0.5; // Subtle left/right movement
                    obj.x = obj.initialX + horizontalOffset;
                    
                    // Update initial Y for reference (used by drawing code)
                    obj.initialY = obj.y;
                });
            }
            
            // Main game loop
            function gameLoop(timestamp) {
                // Calculate delta time
                const deltaTime = timestamp - lastTime;
                lastTime = timestamp;
                
                // Hide all GIF elements first - only show the ones needed
                hideAllGifs();
                
                // Clear the canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Increment animation frame
                animationFrame++;
                
                // Update light flash timer and state for village fair lights
                lightFlashTimer += deltaTime;
                if (lightFlashTimer > 800) { // Slower flashing (800ms) for a more pleasant rhythm
                    lightFlashTimer = 0;
                    lightState = !lightState;
                }
                
                // Always update village objects for the subtle animation
                updateVillageObjects();
                
                // Draw the game scene
                drawScene();
                
                if (gameState === 'playing') {
                    // Update round progression
                    updateRound(timestamp);
                    
                    // Update game objects
                    updatePlayer(deltaTime);
                    
                    // Spawn and update obstacles and pickups
                    spawnCollectibles();
                    updateAlcohols();
                    
                    updateLeaves();
                    
                    spawnEnemies();
                    updateEnemies();
                    
                    // Draw game objects
                    drawPlayer();
                    
                    // Draw alcohols
                    alcohols.forEach(alcohol => {
                        drawAlcohol(alcohol);
                    });
                    
                    // Draw leaves
                    leaves.forEach(leaf => {
                        drawLeaf(leaf);
                    });
                    
                    // Draw enemies
                    enemies.forEach(enemy => {
                        drawEnemy(enemy);
                    });
                    
                    // Draw UI
                    drawEnergyBar();
                } else if (gameState === 'start') {
                    drawStartScreen();
                } else if (gameState === 'gameOver') {
                    drawGameOverScreen();
                } else if (gameState === 'rules') {
                    drawRulesPopup();
                }
                
                requestAnimationFrame(gameLoop);
            }
            
            // Event listeners
            window.addEventListener('keydown', handleKeyDown);
            window.addEventListener('keyup', handleKeyUp);
            
            // Click/tap to start or restart game, or handle UI clicks
            canvas.addEventListener('click', function(e) {
                // Always check for music button click first (works in all game states)
                if (window.musicButton) {
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    // Check if click is on music button
                    if (x >= window.musicButton.x && x <= window.musicButton.x + window.musicButton.width &&
                        y >= window.musicButton.y && y <= window.musicButton.y + window.musicButton.height) {
                        console.log('ðŸŽµ Music button clicked!');
                        toggleMusic();
                        return;
                    }
                }
                
                if (gameState === 'start') {
                    // Check if clicking on Rules button
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    // Use stored button positions for accurate detection
                    if (window.buttonPositions) {
                        const rulesBtn = window.buttonPositions.rules;
                        const tapBtn = window.buttonPositions.tapToStart;
                        
                        // Check if click is near Rules button (within 80px horizontally, 25px vertically)
                        if (Math.abs(x - rulesBtn.x) < 80 && Math.abs(y - rulesBtn.y) < 25) {
                            gameState = 'rules';
                            return;
                        }
                        
                        // Check if click is near Tap to Start button
                        if (Math.abs(x - tapBtn.x) < 120 && Math.abs(y - tapBtn.y) < 25) {
                            startGame();
                            return;
                        }
                    }
                } else if (gameState === 'rules') {
                    // Close rules popup
                    gameState = 'start';
                    return;
                }
                
                // If not playing or not clicking special buttons, start/restart game
                if (gameState !== 'playing' && gameState !== 'rules') {
                    startGame();
                }
            });
            canvas.addEventListener('touchstart', function(e) {
                e.preventDefault(); // Prevent double-firing of events
                
                // Always check for music button touch first (works in all game states)
                if (window.musicButton) {
                    const rect = canvas.getBoundingClientRect();
                    const touch = e.touches[0];
                    const x = touch.clientX - rect.left;
                    const y = touch.clientY - rect.top;
                    
                    // Check if touch is on music button
                    if (x >= window.musicButton.x && x <= window.musicButton.x + window.musicButton.width &&
                        y >= window.musicButton.y && y <= window.musicButton.y + window.musicButton.height) {
                        console.log('ðŸŽµ Music button touched!');
                        toggleMusic();
                        return;
                    }
                }
                
                if (gameState === 'start') {
                    // Check if touching Rules button
                    const rect = canvas.getBoundingClientRect();
                    const touch = e.touches[0];
                    const x = touch.clientX - rect.left;
                    const y = touch.clientY - rect.top;
                    
                    // Use stored button positions for accurate detection
                    if (window.buttonPositions) {
                        const rulesBtn = window.buttonPositions.rules;
                        const tapBtn = window.buttonPositions.tapToStart;
                        
                        // Check if touch is near Rules button
                        if (Math.abs(x - rulesBtn.x) < 80 && Math.abs(y - rulesBtn.y) < 25) {
                            gameState = 'rules';
                            return;
                        }
                        
                        // Check if touch is near Tap to Start button
                        if (Math.abs(x - tapBtn.x) < 120 && Math.abs(y - tapBtn.y) < 25) {
                            startGame();
                            return;
                        }
                    }
                } else if (gameState === 'rules') {
                    // Close rules popup
                    gameState = 'start';
                    return;
                }
                
                // If not playing or not touching special buttons, start/restart game
                if (gameState !== 'playing' && gameState !== 'rules') {
                    startGame();
                }
            });
            
            // ULTIMATE double-tap zoom prevention - comprehensive solution
            let lastTouchEnd = 0;
            let touchStartTime = 0;
            let tapCount = 0;
            let tapTimer = null;
            let lastTapX = 0;
            let lastTapY = 0;
            
            // Primary touchstart handler - prevents all zoom attempts
            document.addEventListener('touchstart', function(e) {
                touchStartTime = Date.now();
                
                // Prevent pinch gestures immediately
                if (e.touches.length > 1) {
                    e.preventDefault();
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                    return false;
                }
                
                // Track tap location and timing for double-tap detection
                const touch = e.touches[0];
                const now = Date.now();
                const tapX = touch.clientX;
                const tapY = touch.clientY;
                
                // Check if touch is on mobile control buttons - allow rapid tapping on controls
                let isOnControlButton = false;
                if (gameState === 'playing') {
                    const leftBtn = document.getElementById('leftBtn');
                    const rightBtn = document.getElementById('rightBtn');
                    
                    if (leftBtn && rightBtn) {
                        const leftBtnRect = leftBtn.getBoundingClientRect();
                        const rightBtnRect = rightBtn.getBoundingClientRect();
                        
                        // Check if touch is within left button area (with extra margin for easier tapping)
                        if (tapX >= leftBtnRect.left - 20 && tapX <= leftBtnRect.right + 20 &&
                            tapY >= leftBtnRect.top - 20 && tapY <= leftBtnRect.bottom + 20) {
                            isOnControlButton = true;
                        }
                        
                        // Check if touch is within right button area (with extra margin for easier tapping)
                        if (tapX >= rightBtnRect.left - 20 && tapX <= rightBtnRect.right + 20 &&
                            tapY >= rightBtnRect.top - 20 && tapY <= rightBtnRect.bottom + 20) {
                            isOnControlButton = true;
                        }
                    }
                }
                
                // If touching control buttons, skip double-tap prevention
                if (isOnControlButton) {
                    return; // Allow the touch to proceed normally
                }
                
                // Clear existing timer
                if (tapTimer) {
                    clearTimeout(tapTimer);
                    tapTimer = null;
                }
                
                // Check if this is a potential double-tap (within 300ms and 50px radius)
                const timeDiff = now - lastTouchEnd;
                const distanceX = Math.abs(tapX - lastTapX);
                const distanceY = Math.abs(tapY - lastTapY);
                const distance = Math.sqrt(distanceX * distanceX + distanceY * distanceY);
                
                if (timeDiff < 350 && distance < 50) {
                    // This is a double-tap! Block it completely
                    e.preventDefault();
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                    tapCount = 0; // Reset
                    return false;
                }
                
                // Store tap info
                lastTapX = tapX;
                lastTapY = tapY;
                tapCount++;
                
                // Auto-reset tap count after timeout
                tapTimer = setTimeout(() => {
                    tapCount = 0;
                }, 350);
                
            }, { passive: false, capture: true });
            
            // Primary touchend handler - additional protection
            document.addEventListener('touchend', function(e) {
                const now = Date.now();
                
                // Check if touch ended on mobile control buttons - allow rapid tapping on controls
                let isOnControlButton = false;
                if (gameState === 'playing' && e.changedTouches.length > 0) {
                    const touch = e.changedTouches[0];
                    const tapX = touch.clientX;
                    const tapY = touch.clientY;
                    
                    const leftBtn = document.getElementById('leftBtn');
                    const rightBtn = document.getElementById('rightBtn');
                    
                    if (leftBtn && rightBtn) {
                        const leftBtnRect = leftBtn.getBoundingClientRect();
                        const rightBtnRect = rightBtn.getBoundingClientRect();
                        
                        // Check if touch ended within left button area (with extra margin)
                        if (tapX >= leftBtnRect.left - 20 && tapX <= leftBtnRect.right + 20 &&
                            tapY >= leftBtnRect.top - 20 && tapY <= leftBtnRect.bottom + 20) {
                            isOnControlButton = true;
                        }
                        
                        // Check if touch ended within right button area (with extra margin)
                        if (tapX >= rightBtnRect.left - 20 && tapX <= rightBtnRect.right + 20 &&
                            tapY >= rightBtnRect.top - 20 && tapY <= rightBtnRect.bottom + 20) {
                            isOnControlButton = true;
                        }
                    }
                }
                
                // If ending touch on control buttons, skip rapid touch prevention
                if (isOnControlButton) {
                    lastTouchEnd = now; // Still update timing for other areas
                    return; // Allow the touch to proceed normally
                }
                
                // Block rapid successive touches (double-tap protection)
                if (now - lastTouchEnd <= 300) {
                    e.preventDefault();
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                    return false;
                }
                
                // Block very quick taps (accidental touches)
                const touchDuration = now - touchStartTime;
                if (touchDuration < 30) {
                    e.preventDefault();
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                    return false;
                }
                
                lastTouchEnd = now;
                
            }, { passive: false, capture: true });
            
            // iOS Safari gesture prevention
            ['gesturestart', 'gesturechange', 'gestureend'].forEach(eventType => {
                document.addEventListener(eventType, function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                    return false;
                }, { passive: false, capture: true });
            });
            
            // Touchmove protection
            document.addEventListener('touchmove', function(e) {
                // Block multi-touch moves
                if (e.touches.length > 1) {
                    e.preventDefault();
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                    return false;
                }
                
                // Block any scaling attempts
                if (e.scale && e.scale !== 1) {
                    e.preventDefault();
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                    return false;
                }
            }, { passive: false, capture: true });
            
            // Prevent mouse wheel zoom (for desktop testing)
            document.addEventListener('wheel', function(e) {
                if (e.ctrlKey) {
                    e.preventDefault(); // Prevent Ctrl+scroll zoom
                }
            }, { passive: false });
            
            // Prevent keyboard zoom shortcuts
            document.addEventListener('keydown', function(e) {
                if ((e.ctrlKey || e.metaKey) && (e.keyCode === 61 || e.keyCode === 107 || e.keyCode === 173 || e.keyCode === 109 || e.keyCode === 187 || e.keyCode === 189)) {
                    e.preventDefault(); // Prevent Ctrl/Cmd + +/- zoom
                }
            });
            
            // Prevent context menu on long press
            document.addEventListener('contextmenu', function(e) {
                e.preventDefault();
            });
            
            // Additional gesture prevention for older Android devices
            document.addEventListener('gesturestart', function(e) {
                e.preventDefault();
            });
            
            document.addEventListener('gesturechange', function(e) {
                e.preventDefault();
            });
            
            document.addEventListener('gestureend', function(e) {
                e.preventDefault();
            });
            
            // Set up mobile controls
            setupMobileControls();
            
            // Handle window resize
            window.addEventListener('resize', resizeCanvas);
            
            // Initialize game
            init();
        });
    </script>
</body>
</html>
