<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="format-detection" content="telephone=no">
    <title>The Bhaava Game</title>
    <!-- Google Fonts - Press Start 2P for retro game feel -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        * {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
            touch-action: none;
            -webkit-tap-highlight-color: transparent;
        }
        
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #111;
            font-family: 'Press Start 2P', cursive, Arial, sans-serif;
            color: white;
        }
        
        .game-title {
            font-family: 'Press Start 2P', cursive;
            color: #FFD700; /* Gold color */
            text-shadow: 4px 4px 0px #000, -2px -2px 0px #8B4513;
            text-align: center;
            font-size: 28px;
        }
        
        .game-message {
            font-family: 'Press Start 2P', cursive;
            color: #FFFFFF;
            text-shadow: 2px 2px 0px #000;
            text-align: center;
            font-size: 16px;
            margin: 15px 0;
        }
        
        /* Ensure portrait orientation on mobile */
        @media screen and (max-width: 812px) and (orientation: landscape) {
            #rotation-message {
                display: flex !important;
            }
        }
        
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            touch-action: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
        }
        
        #game {
            display: block;
            width: 100%;
            height: 100%;
            touch-action: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        
        #mobileControls {
            position: fixed;
            bottom: 20px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            padding: 0 10%;
            z-index: 100;
            pointer-events: auto;
        }
        
        .controlBtn {
            width: 100px; /* Larger touch targets */
            height: 100px;
            background-color: rgba(255, 255, 255, 0.4);
            border: 2px solid rgba(255, 255, 255, 0.6);
            border-radius: 50%;
            position: relative;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation; /* Improved touch handling */
            /* Ensure no text or arrows are displayed */
            font-size: 0;
            color: transparent;
            text-shadow: none;
            /* Hide controls initially until game starts */
            display: none;
        }
        
        /* Removed arrow styling for cleaner mobile experience */
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="game"></canvas>
        
        <!-- Background music -->
        <audio id="backgroundMusic" loop>
            <source src="artifacts/chiptune.wav" type="audio/wav">
        </audio>
        
        <!-- Music toggle button -->
        <button id="musicToggle" style="position: absolute; top: 10px; right: 10px; z-index: 100; padding: 8px 12px; background: rgba(0,0,0,0.7); color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 14px;">
            ðŸ”Š Music
        </button>
        
        <div id="mobileControls">
            <div id="leftBtn" class="controlBtn"></div>
            <div id="rightBtn" class="controlBtn"></div>
        </div>
        
        <div id="rotation-message" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.9); color: white; flex-direction: column; align-items: center; justify-content: center; z-index: 1000;">
            <div style="text-align: center; padding: 20px;">
                <h2>Please Rotate Your Device</h2>
                <p>This game is designed to be played in portrait mode.</p>
                <div style="font-size: 40px; margin: 20px; transform: rotate(90deg);">ðŸ“±â†»</div>
            </div>
        </div>
    </div>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            console.log("Game starting...");
            
            // Detect mobile device
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            console.log("Is mobile device:", isMobile);
            
            // Canvas setup
            const canvas = document.getElementById('game');
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            
            // Enable pixelation
            ctx.imageSmoothingEnabled = false;  // Turn off anti-aliasing for pixelated look
            
            // Global variables
            let roadWidth = 0;
            let roadLeft = 0;
            let animationFrame = 0;
            let lightFlashTimer = 0;
            let lightState = false;
            let lastTime = 0;
            let gameState = 'start'; // start, playing, gameOver
            let gameOverReason = "Bhaava ran out of kudi!"; // Default game over message
            
            // Houses - village style
            let houses = []; // Will be initialized after canvas is ready
            
            // Village objects (sprites from images)
            let villageObjects = []; // Will be initialized after canvas is ready
            
            // Set canvas size to container
            function resizeCanvas() {
                console.log("Resizing canvas...");
                const container = document.getElementById('game-container');
                canvas.width = container.clientWidth;
                canvas.height = container.clientHeight;
                
                // Hide all GIFs on resize since their positions need to be recalculated
                hideAllGifs();
                
                // Calculate road dimensions
                roadWidth = canvas.width * 0.75; // Increased road width
                roadLeft = (canvas.width - roadWidth) / 2;
                
                // Initialize houses with larger sizes and better positioning
                // Calculate house sizes based on screen size (larger than before)
                const houseSize1 = Math.min(6, Math.max(3, Math.floor(canvas.width / 200))); // Increased size
                const houseSize2 = Math.min(7, Math.max(4, Math.floor(canvas.width / 180))); // Increased size
                
                // Calculate safe positions ensuring houses stay on green patches
                const leftPatchWidth = Math.max(30, roadLeft * 0.5); 
                const rightPatchStart = roadLeft + roadWidth + 10;
                
                // We're no longer using traditional houses
                houses = [];
                
                // Scale factor for village objects (based on screen size)
                const baseScale = Math.min(0.5, Math.max(0.2, canvas.width / 1500));
                
                // Calculate equal spacing for objects
                const totalObjects = 2;  // petti, scooter2 (house1 disabled)
                const verticalSpacing = canvas.height / (totalObjects + 1);
                const rightPatchCenter = rightPatchStart + ((canvas.width - rightPatchStart) / 2);
                
                // Initialize village objects with proper positioning on the right side
                // Position them just to the right of the road facing inward (toward the road)
                const rightSideX = roadLeft + roadWidth + 5; // Position very close to the road
                
                // Define positions for continuous vertical movement with much greater spacing
                const positions = [
                    canvas.height * 1.6,    // Far bottom - well below screen
                    canvas.height * 1.0,    // Lower visible position (bottom of screen)
                    canvas.height * 0.3,    // Middle visible position (much more space from bottom)
                    canvas.height * -0.4    // Top position (far above screen to ensure big gaps)
                ];
                
                // Calculate left side position (similar distance from road but on the left)
                const leftSideX = roadLeft * 0.2; // Position close to the road on the left side
                
                villageObjects = [
                    // RIGHT SIDE OBJECTS
                    // First object: petti - start at the very bottom position
                    { 
                        type: 'petti',
                        x: roadLeft + roadWidth * 0.8, // On the right side of road
                        y: positions[0], // Far below screen initially
                        scale: 0.08, // Reduced size
                        side: 'right',
                        initialY: positions[0],
                        faceRoad: true,
                        rolling: false
                    },
                    // Second object: scooter2 - start at bottom visible position
                    { 
                        type: 'scooter2',
                        x: roadLeft + roadWidth * 0.98, // Moved further to the right
                        y: positions[1], // Lower visible position (bottom of screen)
                        scale: 0.075, // Increased size
                        side: 'right',
                        initialY: positions[1],
                        faceRoad: true,
                        rolling: false
                    },
                    // Third object: house1 - DISABLED (commented out)
                    /*{ 
                        type: 'house1',
                        x: roadLeft + roadWidth * 0.9, // On the right side of road
                        y: positions[2], // Middle position with more space from bottom
                        scale: 0.16,
                        side: 'right',
                        initialY: positions[2],
                        faceRoad: true,
                        rolling: false
                    },*/
                    
                    // LEFT SIDE OBJECTS
                    // Fourth object: tuktuk - start at a different position on left side
                    { 
                        type: 'tuktuk',
                        x: roadLeft * 0.002, // Moved much more to the left (was 0.1)
                        y: positions[1] - canvas.height * 0.3, // Offset from right side positions for variety
                        scale: 0.13, // Further increased size (was 0.11)
                        side: 'left',
                        initialY: positions[1] - canvas.height * 0.2,
                        faceRoad: false, // No need to flip, naturally faces right
                        rolling: false
                    },
                    // Fifth object: house1 (replacing house2) - another position on left side - DISABLED
                    /*{ 
                        type: 'house1',
                        x: roadLeft * 0.05, // Moved further to the left (was 0.1)
                        y: positions[0] - canvas.height * 0.3, // Different offset for variety
                        scale: 0.16, // Same size as the other house1
                        side: 'left',
                        initialY: positions[0] - canvas.height * 0.3,
                        faceRoad: false, // No need to flip, naturally faces right
                        rolling: false
                    }*/
                ];
                
                console.log('Road dimensions:', {roadLeft, roadWidth});
                console.log('Right side X position:', rightSideX);
                
                console.log(`Canvas size: ${canvas.width}x${canvas.height}`);
                console.log(`Village objects initialized: ${villageObjects.length}`);
            }
            
            // Image loading system
            const images = {};
            // Track animated GIF elements
            const gifElements = {};
            const imagesToLoad = [
                // Animated GIFs need special handling
                { name: 'bhaavaHappy', src: 'artifacts/bhaava-happy.GIF', isGif: true },
                { name: 'bhaavaNeutral', src: 'artifacts/bhaava-neutral.GIF', isGif: true },
                { name: 'bhaavaSad', src: 'artifacts/bhaava-sad.GIF', isGif: true },
                { name: 'oldmonk', src: 'artifacts/oldmonk.PNG' },
                { name: 'leaves', src: 'artifacts/leaves.PNG' },
                { name: 'raviAnna', src: 'artifacts/ravi-anna.GIF', isGif: true },
                { name: 'char1', src: 'artifacts/char1.GIF', isGif: true },
                { name: 'char2', src: 'artifacts/char2.GIF', isGif: true },
                { name: 'char3', src: 'artifacts/char3.GIF', isGif: true },
                { name: 'char4', src: 'artifacts/char4.GIF', isGif: true },
                { name: 'char5', src: 'artifacts/char5.GIF', isGif: true },
                { name: 'guru', src: 'artifacts/guru.GIF', isGif: true },
                // Village objects
                { name: 'petti', src: 'artifacts/petti.PNG' },
                { name: 'scooter2', src: 'artifacts/scooter2.PNG' },
                // House disabled { name: 'house1', src: 'artifacts/house1.PNG' },
                { name: 'tuktuk', src: 'artifacts/tuktuk.PNG' }
            ];
            
            // Player setup
            const player = {
                x: 0,
                y: 0,
                width: 100,
                height: 130,
                speed: 5,
                energy: 100,
                direction: 0,  // -1: left, 0: still, 1: right
                frameX: 0,
                frameCount: 4,
                frameTimer: 0,
                frameInterval: 100, // ms
                isHit: false,
                isHappy: false
            };
            
            // Game variables
            let score = 0;
            let currentRound = 1;
            let roundStartTime = 0;
            let roundDuration = 10000; // 10 seconds per round
            let guruSpawnedThisRound = 0;
            
            // Round transition notification
            let showRoundTransition = false;
            let roundTransitionStartTime = 0;
            let roundTransitionDuration = 2000; // Show for 2 seconds
            
            // Music control
            let musicEnabled = true;
            let backgroundMusic = null;
            let musicToggleButton = null;
            
            const alcohols = [];
            const leaves = [];
            const enemies = [];
            
            // Helper function to check if a new object would overlap with existing objects
            function isPositionClear(x, y, width, height, buffer = 50) {
                // Check against alcohols
                for (let i = 0; i < alcohols.length; i++) {
                    if (Math.abs(alcohols[i].x - x) < (alcohols[i].width + width) / 2 + buffer &&
                        Math.abs(alcohols[i].y - y) < (alcohols[i].height + height) / 2 + buffer) {
                        return false;
                    }
                }
                
                // Check against leaves
                for (let i = 0; i < leaves.length; i++) {
                    if (Math.abs((leaves[i].x || 0) - x) < ((leaves[i].width || 40) + width) / 2 + buffer &&
                        Math.abs(leaves[i].y - y) < ((leaves[i].height || 40) + height) / 2 + buffer) {
                        return false;
                    }
                }
                
                // Check against enemies
                for (let i = 0; i < enemies.length; i++) {
                    if (Math.abs(enemies[i].x - x) < (enemies[i].width + width) / 2 + buffer &&
                        Math.abs(enemies[i].y - y) < (enemies[i].height + height) / 2 + buffer) {
                        return false;
                    }
                }
                
                return true;
            }
            
            // Game progression system - calculate spawn rates based on round
            function getCollectibleSpawnRate() {
                if (currentRound <= 5) return 0.01; // Same low rate for first 5 rounds
                return 0.018; // Slight increase after round 5
            }
            
            function getLeafSpawnRate() {
                if (currentRound <= 5) return 0.008; // Same low rate for first 5 rounds
                return 0.015; // Moderate increase after round 5
            }
            
            function getEnemyCount() {
                return Math.min(2 + currentRound - 1, 8); // Start with 2, increase by 1 each round, max 8
            }
            
            function getGuruCount() {
                return Math.min(Math.floor((currentRound + 1) / 2), 3); // 1 guru rounds 1-2, 2 gurus rounds 3-4, etc.
            }
            
            // Speed progression functions
            function getObjectSpeed() {
                const baseSpeed = 1.5; // Reduced from 3
                const speedMultiplier = 1 + (currentRound - 1) * 0.15; // Reduced from 0.3 to 0.15
                return baseSpeed * speedMultiplier;
            }
            
            function getLeafSpeed() {
                const baseSpeed = 1.2; // Reduced from 2
                const speedMultiplier = 1 + (currentRound - 1) * 0.12; // Reduced from 0.25 to 0.12
                return baseSpeed * speedMultiplier;
            }
            
            // Round management
            function updateRound(currentTime) {
                if (roundStartTime === 0) {
                    roundStartTime = currentTime;
                }
                
                if (currentTime - roundStartTime >= roundDuration) {
                    // Advance to next round
                    currentRound++;
                    roundStartTime = currentTime;
                    guruSpawnedThisRound = 0;
                    
                    console.log(`Advanced to Round ${currentRound}`);
                }
            }
            
            // Function to update GIF element position to match canvas coordinates
            function updateGifPosition(imageKey, x, y, width, height) {
                const gif = gifElements[imageKey];
                if (!gif) return;
                
                // Convert canvas coordinates to page coordinates
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                
                // Calculate the scaled position and size
                const scaledX = x / scaleX + rect.left;
                const scaledY = y / scaleY + rect.top;
                const scaledWidth = width / scaleX;
                const scaledHeight = height / scaleY;
                
                // Update the GIF element
                gif.style.position = 'fixed';
                gif.style.left = `${scaledX}px`;
                gif.style.top = `${scaledY}px`;
                gif.style.width = `${scaledWidth}px`;
                gif.style.height = `${scaledHeight}px`;
                gif.style.visibility = 'visible';
                gif.style.zIndex = '1000'; // Make sure it's on top
            }
            
            // Hide all GIF elements when not in use
            function hideAllGifs() {
                for (const key in gifElements) {
                    if (gifElements[key]) {
                        gifElements[key].style.visibility = 'hidden';
                    }
                }
            }
            
            // Music control functions
            function initMusic() {
                backgroundMusic = document.getElementById('backgroundMusic');
                musicToggleButton = document.getElementById('musicToggle');
                
                // Set initial volume
                backgroundMusic.volume = 0.3;
                
                // Add click event to toggle button
                musicToggleButton.addEventListener('click', toggleMusic);
                
                // Update button text
                updateMusicButtonText();
            }
            
            function toggleMusic() {
                musicEnabled = !musicEnabled;
                updateMusicButtonText();
                
                if (gameState === 'playing') {
                    if (musicEnabled) {
                        playBackgroundMusic();
                    } else {
                        stopBackgroundMusic();
                    }
                }
            }
            
            function updateMusicButtonText() {
                if (musicToggleButton) {
                    musicToggleButton.textContent = musicEnabled ? 'ðŸ”Š Music' : 'ðŸ”‡ Music';
                }
            }
            
            function playBackgroundMusic() {
                if (backgroundMusic && musicEnabled) {
                    backgroundMusic.currentTime = 0; // Reset to beginning
                    backgroundMusic.play().catch(e => {
                        console.log('Could not play music:', e);
                    });
                }
            }
            
            function stopBackgroundMusic() {
                if (backgroundMusic) {
                    backgroundMusic.pause();
                }
            }
            
            // Initialize the game
            function init() {
                // Initialize music controls
                initMusic();
                
                // Show loading screen
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#fff';
                ctx.font = "24px 'Press Start 2P', monospace"; // Changed to Press Start 2P
                ctx.textAlign = 'center';
                ctx.fillText('Loading...', canvas.width/2, canvas.height/2);
                
                // Load images before starting the game
                loadImages(() => {
                    resizeCanvas();
                    
                    // Position player at bottom center
                    player.x = canvas.width / 2;
                    player.y = canvas.height - 150;
                    
                    // Start game loop
                    requestAnimationFrame(gameLoop);
                });
            }
            
            // Image loading function
            function loadImages(callback) {
                let imagesToLoadCount = imagesToLoad.length;
                console.log(`Loading ${imagesToLoadCount} images...`);
                
                // Create container for GIF elements if it doesn't exist
                let gifContainer = document.getElementById('gif-container');
                if (!gifContainer) {
                    gifContainer = document.createElement('div');
                    gifContainer.id = 'gif-container';
                    gifContainer.style.position = 'absolute';
                    gifContainer.style.top = '-9999px';
                    gifContainer.style.left = '-9999px';
                    gifContainer.style.visibility = 'hidden';
                    document.body.appendChild(gifContainer);
                }
                
                // Check if all images are loaded
                function onLoad() {
                    imagesToLoadCount--;
                    console.log(`Image loaded, ${imagesToLoadCount} remaining.`);
                    if (imagesToLoadCount === 0) {
                        console.log('All images loaded successfully!');
                        // Debug village object images specifically
                        console.log('Village object images loaded?');
                        console.log('petti:', !!images['petti']);
                        console.log('scooter2:', !!images['scooter2']);
                        // House disabled console.log('house1:', !!images['house1']);
                        console.log('tuktuk:', !!images['tuktuk']);
                        console.log('guru:', !!images['guru']);
                        console.log('All image keys:', Object.keys(images));
                        console.log('GIF elements:', Object.keys(gifElements));
                        callback(); // All images loaded, proceed with game
                    }
                }
                
                // Start loading all images
                imagesToLoad.forEach(img => {
                    if (img.isGif) {
                        // For GIFs, create an actual img element in DOM
                        // This lets the browser animate the GIF naturally
                        const gifImg = document.createElement('img');
                        gifImg.onload = onLoad;
                        gifImg.onerror = function() {
                            console.error('Error loading GIF:', img.src, img.name);
                            onLoad(); // Continue even with error
                        };
                        gifImg.src = img.src;
                        gifImg.style.width = '100px';  // Default size
                        gifImg.style.height = '100px'; // Default size
                        
                        // Add to container and track
                        gifContainer.appendChild(gifImg);
                        gifElements[img.name] = gifImg;
                        
                        // Also create a static image for the canvas as fallback
                        const staticImg = new Image();
                        staticImg.src = img.src;
                        images[img.name] = staticImg;
                    } else {
                        // Regular image loading
                        const image = new Image();
                        image.onload = onLoad;
                        image.onerror = function() {
                            console.error('Error loading image:', img.src, img.name);
                            onLoad(); // Continue even with error
                        };
                        image.src = img.src;
                        images[img.name] = image;
                    }
                });
            }

            // Function to draw a simple lantern (avoiding complex effects)
            function drawLantern(x, y, size) {
                // Draw a simple square lantern instead of a round one
                const lanternSize = size * 3;
                
                // Lantern body
                ctx.fillStyle = '#FF6347'; // Tomato
                ctx.fillRect(x - lanternSize/2, y + size, lanternSize, lanternSize);
                
                // Lantern glow (inner part)
                ctx.fillStyle = '#FFD700'; // Gold
                ctx.fillRect(x - lanternSize/3, y + size + lanternSize/6, lanternSize*2/3, lanternSize*2/3);
                
                // Top cap
                ctx.fillStyle = '#8B4513'; // Brown
                ctx.fillRect(x - size, y, size*2, size);
                
                // Hanging string
                ctx.strokeStyle = '#D3D3D3';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x, y - size*2);
                ctx.stroke();
            }
            
            // Function to draw a simpler light
            function drawGlowingLight(x, y, size, color) {
                // Just draw a simple colored circle - no glow effects to avoid issues
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
                
                // Add a white center for a simple light effect
                ctx.fillStyle = '#FFFFFF';
                ctx.beginPath();
                ctx.arc(x, y, size/2, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Draw the scene with wedding decorations
            function drawScene() {
                const pixelSize = 4;  // Size of each "pixel" in our pixel art
                
                // Dark background (night)
                ctx.fillStyle = '#111111';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw grass on both sides of the road
                const baseGrassColor = '#1e8449';  // Darker green base
                const darkGrassColor = '#196f3d';  // Even darker green for texture
                
                // Left side grass
                ctx.fillStyle = baseGrassColor;
                ctx.fillRect(0, 0, roadLeft, canvas.height);
                
                // Right side grass
                ctx.fillRect(roadLeft + roadWidth, 0, canvas.width - (roadLeft + roadWidth), canvas.height);
                
                // Add grass texture (scattered darker green dots)
                for (let x = 0; x < canvas.width; x += pixelSize * 2) {
                    for (let y = 0; y < canvas.height; y += pixelSize * 2) {
                        // Only draw on grass areas
                        if (x < roadLeft || x > roadLeft + roadWidth) {
                            // Create a deterministic pattern based on position
                            if ((x + y) % 7 === 0) {
                                ctx.fillStyle = darkGrassColor;
                                ctx.fillRect(x, y, pixelSize, pixelSize);
                            }
                        }
                    }
                }
                
                // Draw traditional Indian village houses on the sides
                const drawIndianHouse = (x, y, size, mirrored = false) => {
                    // House base colors
                    const wallColor = '#e8d8c3';      // Mud/clay color
                    const darkWallColor = '#c9b18c';  // Darker mud accent
                    const roofColor = '#873600';      // Deep red-brown roof
                    const doorColor = '#5d4037';      // Dark wooden door
                    
                    const width = size * 10;
                    const height = size * 8;
                    
                    // Wall/base of the house
                    ctx.fillStyle = wallColor;
                    ctx.fillRect(x, y, width, height);
                    
                    // Wall texture
                    ctx.fillStyle = darkWallColor;
                    for (let wx = 0; wx < width; wx += size) {
                        for (let wy = 0; wy < height; wy += size * 2) {
                            if ((wx + wy) % (size * 3) === 0) {
                                ctx.fillRect(x + wx, y + wy, size, size);
                            }
                        }
                    }
                    
                    // Triangular roof or sloped roof
                    ctx.fillStyle = roofColor;
                    ctx.beginPath();
                    if (mirrored) {
                        ctx.moveTo(x, y);
                        ctx.lineTo(x + width, y);
                        ctx.lineTo(x + width + size * 2, y - size * 3);
                        ctx.lineTo(x - size * 2, y - size * 3);
                    } else {
                        ctx.moveTo(x - size * 2, y);
                        ctx.lineTo(x + width + size * 2, y);
                        ctx.lineTo(x + width, y - size * 3);
                        ctx.lineTo(x, y - size * 3);
                    }
                    ctx.fill();
                    
                    // Door
                    ctx.fillStyle = doorColor;
                    const doorWidth = size * 3;
                    const doorHeight = size * 4;
                    ctx.fillRect(x + (width - doorWidth) / 2, y + height - doorHeight, doorWidth, doorHeight);
                    
                    // Window(s)
                    ctx.fillStyle = '#ecf0f1';  // Light color for windows
                    const windowSize = size * 2;
                    if (width > size * 7) {
                        // Two windows if house is wide enough
                        ctx.fillRect(x + size * 2, y + size * 2, windowSize, windowSize);
                        ctx.fillRect(x + width - size * 2 - windowSize, y + size * 2, windowSize, windowSize);
                    } else {
                        // One window for smaller houses
                        ctx.fillRect(x + (width - windowSize) / 2, y + size * 2, windowSize, windowSize);
                    }
                };
                
                // Houses have been removed for simplicity
                
                // Draw water well - common in Indian villages
                const drawWell = (x, y, size) => {
                    const wellColor = '#7f8c8d';      // Stone color
                    const darkWellColor = '#2c3e50';  // Darker stone
                    const ropeColor = '#8b4513';      // Rope color
                    const bucketColor = '#e74c3c';    // Bucket color
                    
                    const wellSize = size * 8;
                    
                    // Main well circle
                    ctx.fillStyle = wellColor;
                    ctx.beginPath();
                    ctx.arc(x + wellSize/2, y + wellSize/2, wellSize/2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Inner circle (water)
                    ctx.fillStyle = '#3498db'; // Water color
                    ctx.beginPath();
                    ctx.arc(x + wellSize/2, y + wellSize/2, wellSize/3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Wooden structure above well
                    ctx.fillStyle = darkWellColor;
                    ctx.fillRect(x, y - size * 6, wellSize, size * 2);  // Horizontal beam
                    ctx.fillRect(x, y - size * 6, size * 2, size * 6);  // Left post
                    ctx.fillRect(x + wellSize - size * 2, y - size * 6, size * 2, size * 6);  // Right post
                    
                    // Rope and bucket
                    ctx.fillStyle = ropeColor;
                    ctx.fillRect(x + wellSize/2, y - size * 6, size, size * 4);  // Rope
                    
                    ctx.fillStyle = bucketColor;
                    ctx.fillRect(x + wellSize/2 - size, y - size * 2, size * 2, size * 2);  // Bucket
                };
                
                // Draw a traditional banyan tree
                const drawBanyanTree = (x, y, size) => {
                    // Tree trunk
                    ctx.fillStyle = '#6d4c41'; // Brown trunk
                    ctx.fillRect(x - size * 2, y - size * 10, size * 4, size * 10);
                    
                    // Hanging roots
                    for (let i = 0; i < 5; i++) {
                        const rootX = x - size * 4 + (i * size * 2);
                        ctx.fillRect(rootX, y - size * 8, size, size * 4);
                    }
                    
                    // Foliage (canopy)
                    ctx.fillStyle = '#196f3d'; // Dark green foliage
                    for (let i = 0; i < 3; i++) {
                        const radius = size * 8 - (i * size);
                        ctx.beginPath();
                        ctx.arc(x, y - size * 10 - (i * size * 2), radius, 0, Math.PI * 2);
                        ctx.fill();
                    }
                };
                
                // Draw a small temple
                const drawTemple = (x, y, size) => {
                    // Base
                    ctx.fillStyle = '#d1ccc0'; // Temple stone color
                    ctx.fillRect(x, y - size * 4, size * 8, size * 4);
                    
                    // Steps
                    ctx.fillRect(x + size, y, size * 6, size);
                    
                    // Dome/Shikhara
                    ctx.fillStyle = '#ff9f43'; // Saffron/orange color
                    ctx.beginPath();
                    ctx.moveTo(x, y - size * 4);
                    ctx.lineTo(x + size * 8, y - size * 4);
                    ctx.lineTo(x + size * 4, y - size * 10);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Top ornament
                    ctx.fillStyle = '#f1c40f'; // Gold color
                    ctx.fillRect(x + size * 3.5, y - size * 11, size, size);
                    ctx.beginPath();
                    ctx.arc(x + size * 4, y - size * 12, size, 0, Math.PI * 2);
                    ctx.fill();
                };
                
                // Well and banyan tree have been removed for simplicity
                
                // Add some flowers and small plants to the grass around houses
                const flowerColors = ['#FFFFFF', '#f1c40f', '#e74c3c', '#9b59b6']; // white, yellow, red, purple
                
                // Draw flowers based on animation frame so they don't flicker
                const flowerSeed = Math.floor(animationFrame / 20) % 100;
                
                for (let i = 0; i < 25; i++) {
                    // Deterministic random position
                    const xPos = ((i * 37 + flowerSeed) % canvas.width);
                    const yPos = ((i * 23 + flowerSeed * 7) % canvas.height);
                    
                    // Only draw on grass areas
                    if (xPos < roadLeft - pixelSize*2 || xPos > roadLeft + roadWidth + pixelSize*2) {
                        // Pick a deterministic color based on position
                        const colorIndex = (i + flowerSeed) % flowerColors.length;
                        
                        // Draw a small flower or plant
                        ctx.fillStyle = flowerColors[colorIndex];
                        ctx.fillRect(xPos, yPos, pixelSize, pixelSize);
                        
                        // Some flowers have extra petals
                        if (i % 3 === 0) {
                            ctx.fillRect(xPos - pixelSize, yPos, pixelSize, pixelSize);
                            ctx.fillRect(xPos + pixelSize, yPos, pixelSize, pixelSize);
                        }
                    }
                }
                
                // Draw straight road
                const baseRoadColor = '#8B4513';  // Brown road color
                const darkMudColor = '#654321';   // Darker brown for texture
                const trackColor = '#704214';     // Track color
                
                // Draw the main road
                ctx.fillStyle = baseRoadColor;
                ctx.fillRect(roadLeft, 0, roadWidth, canvas.height);
                
                // Add road texture
                for (let x = roadLeft; x < roadLeft + roadWidth; x += pixelSize * 3) {
                    for (let y = 0; y < canvas.height; y += pixelSize * 3) {
                        // Create a stable pattern based on position
                        if ((Math.floor(x/pixelSize) + Math.floor(y/pixelSize)) % 5 === 0) {
                            ctx.fillStyle = darkMudColor;
                            ctx.fillRect(x, y, pixelSize, pixelSize);
                        }
                    }
                }
                
                // Add track marks
                for (let y = Math.floor(animationFrame % (pixelSize * 10)); y < canvas.height; y += pixelSize * 10) {
                    ctx.fillStyle = trackColor;
                    ctx.fillRect(roadLeft + roadWidth/3, y, pixelSize * 2, pixelSize);
                    ctx.fillRect(roadLeft + roadWidth*2/3, y, pixelSize * 2, pixelSize);
                }
                
                // Draw the village objects BEFORE poles and wires to place them behind
                villageObjects.forEach((obj, index) => {
                    // Make sure the image is loaded
                    if (images[obj.type]) {
                        // Draw the sprite with proper scaling
                        const img = images[obj.type];
                        const width = img.width * obj.scale;
                        const height = img.height * obj.scale;
                        
                        // Apply minimal glow for all objects (both left and right side)
                        const glowRadius = Math.max(width, height) * 0.2; // Minimal glow radius
                        const gradient = ctx.createRadialGradient(
                            obj.x + width/2, obj.y + height/2, 0,
                            obj.x + width/2, obj.y + height/2, glowRadius
                        );
                        gradient.addColorStop(0, 'rgba(255, 255, 200, 0.05)'); // Very minimal glow
                        gradient.addColorStop(1, 'rgba(255, 255, 200, 0)');
                        
                        ctx.fillStyle = gradient;
                        ctx.fillRect(obj.x - glowRadius/2, obj.y - glowRadius/2, 
                                  width + glowRadius, height + glowRadius);
                        
                        // Draw the actual sprite, with proper orientation based on side
                        try {
                            // Objects on the right side facing the road need to be flipped
                            if (obj.side === 'right' && obj.faceRoad) {
                                // Save the current state
                                ctx.save();
                                
                                // Move to the position where we want to draw
                                ctx.translate(obj.x + width/2, obj.y + height/2);
                                
                                // Flip horizontally to face toward the road (left side)
                                ctx.scale(-1, 1);
                                
                                // Draw the image centered at origin (adjusted for the flip)
                                ctx.drawImage(
                                    img, 
                                    -width/2, 
                                    -height/2, 
                                    width, 
                                    height
                                );
                                
                                // Restore the context to its original state
                                ctx.restore();
                            } else {
                                // Draw normally without flipping
                                ctx.drawImage(
                                    img, 
                                    obj.x, 
                                    obj.y, 
                                    width, 
                                    height
                                );
                            }
                        } catch (err) {
                            console.error(`Error drawing ${obj.type}:`, err);
                        }
                        
                        // Debug text removed
                    } else {
                        console.warn(`Image not loaded for object type: ${obj.type}`);
                    }
                });
                
                // Add decorative poles along the road (Indian village fair style)
                const poleSpacing = 200; // Space between poles
                const poleWidth = pixelSize * 3; // Width of each pole
                const poleHeight = 120; // Height of each pole
                
                // Use modulo operation with NEGATIVE value to create upward movement effect
                // This makes poles move upward to match the player running forward
                const poleOffset = (-animationFrame % poleSpacing);
                
                // Draw poles on both sides of the road - adding poles above and below screen to ensure seamless appearance
                for (let y = poleOffset - poleSpacing; y < canvas.height + poleSpacing; y += poleSpacing) {
                    // Left side pole
                    ctx.fillStyle = '#8B4513'; // Brown wooden pole
                    ctx.fillRect(roadLeft - poleWidth - 10, y, poleWidth, poleHeight);
                    
                    // Right side pole
                    ctx.fillRect(roadLeft + roadWidth + 10, y, poleWidth, poleHeight);
                    
                    // Top decorative element for poles (like a lamp post)
                    ctx.fillStyle = '#A0522D'; // Sienna color for top decoration
                    ctx.fillRect(roadLeft - poleWidth - 15, y, poleWidth + 10, 5); // Left pole top
                    ctx.fillRect(roadLeft + roadWidth + 5, y, poleWidth + 10, 5); // Right pole top
                }
                
                // Draw vertical serial lights along the poles (Indian fair style)
                ctx.strokeStyle = '#444444'; // Wire color
                ctx.lineWidth = 2;
                
                // Use the same pole offset calculated above - already set to move upward
                
                for (let y = poleOffset - poleSpacing; y < canvas.height + poleSpacing; y += poleSpacing) {
                    // Draw wires along each side of the road vertically connecting poles
                    const leftPoleX = roadLeft - poleWidth/2 - 10;
                    const rightPoleX = roadLeft + roadWidth + poleWidth/2 + 10;
                    const startY = y + 10; // Attach to pole top
                    const endY = y + poleSpacing; // Connect to next pole
                    
                    // Left side vertical wire
                    ctx.beginPath();
                    ctx.moveTo(leftPoleX, startY);
                    
                    // Create a curve with control points for a natural droop
                    const leftCp1y = startY + (endY - startY) * 0.33; // First control point
                    const leftCp2y = endY - (endY - startY) * 0.33; // Second control point
                    
                    // Draw the curved wire on left side
                    ctx.bezierCurveTo(leftPoleX + 15, leftCp1y, leftPoleX + 15, leftCp2y, leftPoleX, endY);
                    ctx.stroke();
                    
                    // Right side vertical wire - curves to the left like the left wire
                    ctx.beginPath();
                    ctx.moveTo(rightPoleX, startY);
                    
                    // Create a curve with control points for a natural droop
                    const rightCp1y = startY + (endY - startY) * 0.33; // First control point
                    const rightCp2y = endY - (endY - startY) * 0.33; // Second control point
                    
                    // Draw the curved wire on right side (curving to the left)
                    ctx.bezierCurveTo(rightPoleX - 15, rightCp1y, rightPoleX - 15, rightCp2y, rightPoleX, endY);
                    ctx.stroke();
                    
                    // Add flashing lights along the left wire
                    const numLights = 5; // Number of lights on each wire
                    const lightSize = 4;
                    const lightColors = ['#FFD700', '#FF6347', '#4169E1', '#32CD32', '#FF1493']; // Gold, tomato, blue, green, pink
                    
                    for (let i = 0; i < numLights; i++) {
                        const t = i / (numLights - 1); // Parameter along curve (0 to 1)
                        
                        // Calculate positions on the left side curve using the bezier formula
                        const leftLightX = (1-t)*(1-t)*(1-t)*leftPoleX + 
                                          3*(1-t)*(1-t)*t*(leftPoleX + 15) + 
                                          3*(1-t)*t*t*(leftPoleX + 15) + 
                                          t*t*t*leftPoleX;
                        
                        const leftLightY = (1-t)*(1-t)*(1-t)*startY + 
                                          3*(1-t)*(1-t)*t*leftCp1y + 
                                          3*(1-t)*t*t*leftCp2y + 
                                          t*t*t*endY;
                        
                        // Only draw the light if it's currently "on" based on the lightState and position
                        if (lightState || (i % 2 === 0)) { // Alternate pattern for flashing
                            const colorIndex = (i + Math.floor(animationFrame / 20)) % lightColors.length;
                            drawGlowingLight(leftLightX, leftLightY, lightSize, lightColors[colorIndex]);
                        }
                        
                        // Calculate positions on the right side curve using the bezier formula (matching the curve to the left)
                        const rightLightX = (1-t)*(1-t)*(1-t)*rightPoleX + 
                                           3*(1-t)*(1-t)*t*(rightPoleX - 15) + 
                                           3*(1-t)*t*t*(rightPoleX - 15) + 
                                           t*t*t*rightPoleX;
                        
                        const rightLightY = (1-t)*(1-t)*(1-t)*startY + 
                                           3*(1-t)*(1-t)*t*rightCp1y + 
                                           3*(1-t)*t*t*rightCp2y + 
                                           t*t*t*endY;
                        
                        // Only draw the light if it's currently "on" based on the lightState and position
                        if (lightState || (i % 2 === 0)) { // Alternate pattern for flashing
                            const colorIndex = ((i + 2) + Math.floor(animationFrame / 20)) % lightColors.length; // Offset color index for variety
                            drawGlowingLight(rightLightX, rightLightY, lightSize, lightColors[colorIndex]);
                        }
                    }
                }
                
                // Add horizontal serial wire lights connecting poles across the road (only 2 per screen)
                // Select only 2 sets of poles to connect horizontally
                const horizontalWireSpacing = poleSpacing * 3; // Space them out more than the poles
                const horizontalWireOffset = (-animationFrame % horizontalWireSpacing);
                
                for (let y = horizontalWireOffset; y < canvas.height; y += horizontalWireSpacing) {
                    // Only draw if the horizontal wire would be visible
                    if (y > -20 && y < canvas.height + 20) {
                        const leftPoleX = roadLeft - poleWidth/2 - 10;
                        const rightPoleX = roadLeft + roadWidth + poleWidth/2 + 10;
                        const wireY = y + 30; // Position near the top of poles but not at the very top
                        
                        // Draw the horizontal wire with a nice curve
                        ctx.beginPath();
                        ctx.moveTo(leftPoleX, wireY);
                        
                        // Calculate the curve control points
                        const midX = roadLeft + roadWidth/2;
                        const droopAmount = 50; // How much the wire droops in the middle
                        
                        // Draw a curved wire that droops in the middle
                        ctx.quadraticCurveTo(midX, wireY + droopAmount, rightPoleX, wireY);
                        ctx.stroke();
                        
                        // Add decorative lights along the horizontal wire
                        const numLights = 10; // More lights for the horizontal wire
                        const lightSize = 5;
                        const lightColors = ['#FFD700', '#FF6347', '#4169E1', '#32CD32', '#FF1493']; // Gold, tomato, blue, green, pink
                        
                        for (let i = 0; i < numLights; i++) {
                            const t = i / (numLights - 1);
                            
                            // Calculate position along the quadratic curve
                            const lightX = (1-t)*(1-t)*leftPoleX + 2*(1-t)*t*midX + t*t*rightPoleX;
                            const lightY = (1-t)*(1-t)*wireY + 2*(1-t)*t*(wireY + droopAmount) + t*t*wireY;
                            
                            // Only draw the light if it's currently "on" based on the lightState and position
                            if (lightState || (i % 2 === 0)) { // Alternate pattern for flashing
                                const colorIndex = (i + Math.floor(animationFrame / 15)) % lightColors.length;
                                drawGlowingLight(lightX, lightY, lightSize, lightColors[colorIndex]);
                            }
                        }
                    }
                }
                
                // Houses should be drawn BEFORE poles and wires (moving draw logic to earlier in the rendering pipeline)
                // We'll update the house positions here but not draw them yet
                houses.forEach(house => {
                    // Calculate house movement based on animation frame (moving upward)
                    // Move at half the speed of poles for parallax effect
                    const houseSpeed = 0.5; // Half the speed of poles for parallax
                    
                    // Calculate the actual y-position without the modulo yet
                    let adjustedY = house.initialY - (animationFrame * houseSpeed);
                    
                    // Get house height based on size (approximate)
                    const houseHeight = house.size * 12;
                    
                    // When a house moves completely off the top of the screen
                    // We need to wrap it back to below the screen to create seamless looping
                    // The modulo operation needs to account for the full cycle distance
                    const fullCycleHeight = canvas.height + houseHeight * 2;
                    
                    // Apply the wrap-around using modulo, then adjust back to the cycle range
                    adjustedY = adjustedY % fullCycleHeight;
                    if (adjustedY < -houseHeight) {
                        adjustedY += fullCycleHeight;
                    }
                    
                    // Store the updated position
                    house.y = adjustedY;
                });
            }
            
            // Helper function to draw pixelated elements (with less pixelation)
            function drawPixelRect(x, y, width, height, color, pixelSize = 2) {
                ctx.fillStyle = color;
                
                // Draw as a series of larger pixels
                for (let px = 0; px < width; px += pixelSize) {
                    for (let py = 0; py < height; py += pixelSize) {
                        const pixW = Math.min(pixelSize, width - px);
                        const pixH = Math.min(pixelSize, height - py);
                        ctx.fillRect(
                            Math.floor(x + px), 
                            Math.floor(y + py), 
                            Math.ceil(pixW), 
                            Math.ceil(pixH)
                        );
                    }
                }
            }
            
            // Draw the player character using sprites
            function drawPlayer() {
                ctx.save();
                ctx.translate(Math.floor(player.x), Math.floor(player.y));
                
                // Choose between neutral, happy and sad based on player state
                let imageKey = 'bhaavaNeutral'; // Default state is neutral
                
                if (player.isHit) {
                    imageKey = 'bhaavaSad'; // Use sad when hit by enemy
                } else if (player.isHappy) {
                    imageKey = 'bhaavaHappy'; // Use happy when collecting items
                }
                
                // Get both static and animated versions
                let playerImage = images[imageKey];
                let playerGif = gifElements[imageKey];
                
                // Calculate running animation effects - vertical bobbing only when moving
                let runningEffect = 0;
                
                if (player.direction !== 0) {
                    // Apply running animation ONLY when moving (vertical bobbing only)
                    runningEffect = Math.sin(player.frameX * 0.5) * 3; // Vertical movement
                    // No tilting to keep consistent with enemies
                }
                
                // Position for HTML element-based GIFs
                const destX = player.x - player.width/2;
                const destY = player.y - player.height/2 + runningEffect;
                
                // If we have a GIF element, position and show it
                if (playerGif && document.getElementById('gif-container')) {
                    // Position and size the GIF element where it should appear on canvas
                    updateGifPosition(imageKey, destX, destY, player.width, player.height);
                    
                    // Draw placeholder rectangle with low opacity to mark position
                    ctx.fillStyle = 'rgba(255,255,255,0.01)';  // Almost invisible placeholder
                    ctx.fillRect(-player.width/2, -player.height/2 + runningEffect, player.width, player.height);
                } 
                // Fallback to static image if no GIF element
                else if (playerImage && playerImage.complete) {
                    ctx.drawImage(
                        playerImage,
                        0, 0, // Source X, Y
                        playerImage.width, playerImage.height, // Source width, height
                        -player.width/2, -player.height/2 + runningEffect, // Dest X, Y with bounce effect
                        player.width, player.height // Dest width, height
                    );
                } else {
                    // Fallback if image isn't loaded
                    ctx.fillStyle = '#3498db';  // Blue
                    ctx.fillRect(-player.width/2, -player.height/2 + runningEffect, player.width, player.height);
                }
                
                ctx.restore();
            }
            
            // Draw kudi meter (energy bar)
            function drawEnergyBar() {
                const barWidth = 200;
                const barHeight = 20;
                const x = 20;
                const y = 20; // Back to original position
                
                // Background
                ctx.fillStyle = '#333';
                ctx.fillRect(x, y, barWidth, barHeight);
                
                // Energy level
                const energyWidth = (player.energy / 100) * barWidth;
                ctx.fillStyle = player.energy > 30 ? '#2ecc71' : '#e74c3c';
                ctx.fillRect(x, y, energyWidth, barHeight);
                
                // Border
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.strokeRect(x, y, barWidth, barHeight);
                
                // Text inside the bar (same font as homepage)
                ctx.fillStyle = '#fff';
                ctx.font = "12px 'Press Start 2P', monospace"; // Changed to Press Start 2P
                ctx.fillText(`Kudi: ${Math.floor(player.energy)}%`, x + 10, y + 15); // Inside the bar
                
                // Score display (same font as homepage)
                ctx.fillStyle = '#fff';
                ctx.font = "12px 'Press Start 2P', monospace"; // Changed to Press Start 2P
                ctx.fillText(`Score: ${score}`, canvas.width - 120, y + 15);
                
                // Round display
                ctx.fillStyle = '#FFD700'; // Gold color for round
                ctx.font = "12px 'Press Start 2P', monospace"; // Changed to Press Start 2P to match other text
                ctx.fillText(`Roundu: ${currentRound}`, canvas.width - 120, y + 35);
            }
            
            // Draw round transition notification
            function drawRoundTransition(currentTime) {
                if (!showRoundTransition) return;
                
                // Check if transition period is over
                if (currentTime - roundTransitionStartTime >= roundTransitionDuration) {
                    showRoundTransition = false;
                    return;
                }
                
                // Calculate fade effect
                const elapsed = currentTime - roundTransitionStartTime;
                const fadeInTime = 300; // Fade in for 300ms
                const fadeOutTime = 500; // Fade out for last 500ms
                let alpha = 1;
                
                if (elapsed < fadeInTime) {
                    alpha = elapsed / fadeInTime;
                } else if (elapsed > roundTransitionDuration - fadeOutTime) {
                    alpha = (roundTransitionDuration - elapsed) / fadeOutTime;
                }
                
                // Draw semi-transparent background
                ctx.save();
                ctx.fillStyle = `rgba(0, 0, 0, ${alpha * 0.7})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw round text
                ctx.fillStyle = `rgba(255, 215, 0, ${alpha})`; // Gold color with fade
                ctx.font = "bold 48px 'Press Start 2P', monospace"; // Changed to Press Start 2P
                ctx.textAlign = 'center';
                ctx.fillText(`ROUNDU ${currentRound}`, canvas.width / 2, canvas.height / 2 - 20);
                
                // Draw difficulty indicator
                let difficultyText = '';
                if (currentRound === 1) difficultyText = 'Getting Started...';
                else if (currentRound === 2) difficultyText = 'Warming Up...';
                else if (currentRound >= 3 && currentRound <= 5) difficultyText = 'Things Heat Up!';
                else difficultyText = 'Maximum Chaos!';
                
                ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                ctx.font = "bold 24px 'Press Start 2P', monospace"; // Changed to Press Start 2P
                ctx.fillText(difficultyText, canvas.width / 2, canvas.height / 2 + 30);
                
                ctx.restore();
            }
            
            // Draw alcohol bottle
            function drawAlcohol(alcohol) {
                ctx.save();
                ctx.translate(alcohol.x, alcohol.y);
                
                // Draw the alcohol bottle sprite
                if (images.oldmonk && images.oldmonk.complete) {
                    ctx.drawImage(
                        images.oldmonk,
                        0, 0,
                        images.oldmonk.width, images.oldmonk.height,
                        -alcohol.width/2, -alcohol.height/2,
                        alcohol.width, alcohol.height
                    );
                } else {
                    // Fallback if image isn't loaded
                    const bottleWidth = 180;
                    const bottleHeight = 90;
                    
                    // Draw bottle - amber color for whiskey/rum
                    ctx.fillStyle = '#FF8C00';  // Amber
                    ctx.fillRect(-bottleWidth/2, -bottleHeight/2, bottleWidth, bottleHeight);
                    
                    // Bottle neck
                    ctx.fillStyle = '#A0522D';  // Brown
                    ctx.fillRect(-bottleWidth/4, -bottleHeight/2 - 10, bottleWidth/2, 10);
                    
                    // Bottle cap
                    ctx.fillStyle = '#4a4a4a';  // Dark gray
                    ctx.fillRect(-bottleWidth/6, -bottleHeight/2 - 15, bottleWidth/3, 5);
                }
                
                ctx.restore();
            }
            
            // Draw leaf obstacles
            function drawLeaf(leaf) {
                ctx.save();
                ctx.translate(leaf.x, leaf.y);
                
                // Draw the leaf sprite
                if (images.leaves && images.leaves.complete) {
                    ctx.drawImage(
                        images.leaves,
                        0, 0,
                        images.leaves.width, images.leaves.height,
                        -leaf.width/2, -leaf.height/2,
                        leaf.width, leaf.height
                    );
                } else {
                    // Fallback if image isn't loaded
                    ctx.fillStyle = '#27ae60';  // Green
                    
                    // Simple leaf shape
                    ctx.beginPath();
                    ctx.ellipse(0, 0, 15, 25, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Leaf stem
                    ctx.fillStyle = '#7f8c8d';
                    ctx.fillRect(-2, -30, 4, 10);
                }
                
                ctx.restore();
            }
            
            // Draw enemy characters
            function drawEnemy(enemy) {
                // Choose enemy sprite based on type
                let imageKey = enemy.type; // Use type as the key to find the right GIF or image
                
                // If we have a GIF element for this enemy type, position and show it
                if (gifElements[imageKey] && document.getElementById('gif-container')) {
                    // Calculate the position for the GIF element
                    const destX = enemy.x - enemy.width/2;
                    const destY = enemy.y - enemy.height/2;
                    
                    // Position and size the GIF element where it should appear on canvas
                    updateGifPosition(imageKey, destX, destY, enemy.width, enemy.height);
                    
                    // Draw placeholder rectangle with low opacity to mark position (optional)
                    ctx.save();
                    ctx.translate(enemy.x, enemy.y);
                    ctx.fillStyle = 'rgba(255,255,255,0.01)';  // Almost invisible placeholder
                    ctx.fillRect(-enemy.width/2, -enemy.height/2, enemy.width, enemy.height);
                    ctx.restore();
                } 
                // Fallback to static image if no GIF element
                else {
                    ctx.save();
                    ctx.translate(enemy.x, enemy.y);
                    
                    if (images[imageKey] && images[imageKey].complete) {
                        ctx.drawImage(
                            images[imageKey],
                            0, 0, // Source X, Y
                            images[imageKey].width, images[imageKey].height, // Source width, height
                            -enemy.width/2, -enemy.height/2, // Dest X, Y
                            enemy.width, enemy.height // Dest width, height
                        );
                    } else {
                        // Fallback if image isn't loaded
                        ctx.fillStyle = '#e74c3c';  // Red
                        ctx.fillRect(-enemy.width/2, -enemy.height/2, enemy.width, enemy.height);
                    }
                    
                    ctx.restore();
                }
            }
            
            // Update player position and state
            function updatePlayer(deltaTime) {
                // Move player based on direction
                player.x += player.speed * player.direction;
                
                // Keep player within road boundaries
                if (player.x < roadLeft + player.width/2) {
                    player.x = roadLeft + player.width/2;
                } else if (player.x > roadLeft + roadWidth - player.width/2) {
                    player.x = roadLeft + roadWidth - player.width/2;
                }
                
                // Update animation frame (used for movement bobbing only)
                player.frameTimer += deltaTime;
                if (player.frameTimer > player.frameInterval) {
                    player.frameTimer = 0;
                    player.frameX = (player.frameX + 1) % player.frameCount;
                }
                
                // Update energy
                if (player.energy > 0) {
                    player.energy -= 0.05;  // Slowly decrease energy
                }
                
                if (player.energy <= 0 && gameState === 'playing') {
                    gameState = 'gameOver';
                    gameOverReason = "Bhaava ran out of kudi!";
                    stopBackgroundMusic(); // Stop music when game ends
                    console.log("Game Over - Out of kudi");
                }
            }
            
            // Spawn alcohol bottles
            function spawnAlcohol() {
                if (Math.random() < getCollectibleSpawnRate()) {  // Dynamic spawn rate based on round
                    const width = 90;
                    const height = 60;
                    
                    // Try multiple times to find a clear position
                    for (let attempts = 0; attempts < 10; attempts++) {
                        const x = roadLeft + width/2 + Math.random() * (roadWidth - width);
                        const y = -50;
                        
                        if (isPositionClear(x, y, width, height)) {
                            const alcohol = {
                                x: x,
                                y: y,
                                speed: getObjectSpeed() + Math.random() * 2,
                                width: width,
                                height: height
                            };
                            alcohols.push(alcohol);
                            break;
                        }
                    }
                }
            }
            
            // Update alcohol bottles
            function updateAlcohols() {
                for (let i = alcohols.length - 1; i >= 0; i--) {
                    alcohols[i].y += alcohols[i].speed;
                    
                    // Keep alcohol within road boundaries
                    if (alcohols[i].x < roadLeft + alcohols[i].width/2) {
                        alcohols[i].x = roadLeft + alcohols[i].width/2;
                    }
                    if (alcohols[i].x > roadLeft + roadWidth - alcohols[i].width/2) {
                        alcohols[i].x = roadLeft + roadWidth - alcohols[i].width/2;
                    }
                    
                    // Check collision with player
                    if (
                        alcohols[i].y > player.y - player.height/2 && 
                        alcohols[i].y < player.y + player.height/2 && 
                        alcohols[i].x > player.x - player.width/2 && 
                        alcohols[i].x < player.x + player.width/2
                    ) {
                        // Player collected alcohol
                        player.energy = Math.min(100, player.energy + 15);  // Increase energy
                        score += 10;  // Increase score
                        player.isHappy = true; // Make player happy
                        
                        // Reset isHappy after a short delay
                        setTimeout(() => { player.isHappy = false; }, 1000);
                        
                        alcohols.splice(i, 1);
                        continue;
                    }
                    
                    // Remove if off screen
                    if (alcohols[i].y > canvas.height + 50) {
                        alcohols.splice(i, 1);
                    }
                }
            }
            
            // Spawn leaf obstacles
            function spawnLeaves() {
                if (Math.random() < getLeafSpawnRate()) {  // Dynamic spawn rate based on round
                    const width = 45;
                    const height = 45;
                    
                    // Try multiple times to find a clear position
                    for (let attempts = 0; attempts < 10; attempts++) {
                        const x = roadLeft + width/2 + Math.random() * (roadWidth - width);
                        const y = -50;
                        
                        if (isPositionClear(x, y, width, height)) {
                            const leaf = {
                                x: x,
                                y: y,
                                speed: getLeafSpeed() + Math.random() * 3,
                                rotation: Math.random() * Math.PI * 2,
                                rotationSpeed: (Math.random() - 0.5) * 0.1,
                                width: width,
                                height: height
                            };
                            leaves.push(leaf);
                            break;
                        }
                    }
                }
            }
            
            // Update leaf obstacles
            function updateLeaves() {
                for (let i = leaves.length - 1; i >= 0; i--) {
                    leaves[i].y += leaves[i].speed;
                    leaves[i].rotation += leaves[i].rotationSpeed;
                    
                    // Keep leaves within road boundaries
                    if (leaves[i].x < roadLeft + leaves[i].width/2) {
                        leaves[i].x = roadLeft + leaves[i].width/2;
                    }
                    if (leaves[i].x > roadLeft + roadWidth - leaves[i].width/2) {
                        leaves[i].x = roadLeft + roadWidth - leaves[i].width/2;
                    }
                    
                    // Check collision with player
                    if (
                        leaves[i].y > player.y - player.height/2 && 
                        leaves[i].y < player.y + player.height/2 && 
                        leaves[i].x > player.x - player.width/2 && 
                        leaves[i].x < player.x + player.width/2
                    ) {
                        // Player collected leaf
                        player.energy = Math.min(100, player.energy + 10);  // Increase energy
                        score += 5;  // Increase score
                        player.isHappy = true; // Make player happy
                        
                        // Reset isHappy after a short delay
                        setTimeout(() => { player.isHappy = false; }, 1000);
                        
                        leaves.splice(i, 1);
                        continue;
                    }
                    
                    // Remove if off screen
                    if (leaves[i].y > canvas.height + 50) {
                        leaves.splice(i, 1);
                    }
                }
            }
            
            // Spawn enemy characters
            // Define different enemy types
            const enemyTypes = [
                { name: 'raviAnna', type: 'raviAnna', speed: 1.2, width: 75, height: 95 }, // Reduced from 2.5
                { name: 'char1', type: 'char1', speed: 1.3, width: 75, height: 95 }, // Reduced from 3.0
                { name: 'char2', type: 'char2', speed: 1.4, width: 80, height: 100 }, // Reduced from 3.5
                { name: 'char3', type: 'char3', speed: 1.3, width: 75, height: 95 }, // Reduced from 3.0
                { name: 'char4', type: 'char4', speed: 1.35, width: 75, height: 95 }, // Reduced from 3.2
                { name: 'char5', type: 'char5', speed: 1.25, width: 80, height: 100 }, // Reduced from 2.8
                { name: 'Guru', type: 'guru', speed: 1.6, width: 85, height: 110, isDeadly: true } // Reduced from 4.0 - Crucial character - ends game on collision
            ];
            
            let lastEnemyTypeIndex = -1; // Track last spawned enemy type to avoid repetition
            
            function spawnEnemies() {
                // Check current enemy counts on screen
                const currentEnemyCount = enemies.filter(e => e.type !== 'guru').length;
                const currentGuruCount = enemies.filter(e => e.type === 'guru').length;
                
                // Get maximum allowed enemies for current round
                const maxEnemies = getEnemyCount();
                const maxGurus = getGuruCount();
                
                // Don't spawn if we already have enough enemies for this round
                if (currentEnemyCount >= maxEnemies && currentGuruCount >= maxGurus) {
                    return;
                }
                
                if (Math.random() < 0.008) {  // Lower base spawn probability for better balance
                    // Get a random enemy type, avoiding the same type twice in a row
                    let typeIndex;
                    
                    // Try to spawn guru if we haven't reached the limit
                    if (currentGuruCount < maxGurus && Math.random() < 0.2) {
                        // Spawn guru (assuming it's the last enemy in the array)
                        typeIndex = enemyTypes.length - 1;
                    } else if (currentEnemyCount < maxEnemies) {
                        // Spawn regular enemy
                        do {
                            typeIndex = Math.floor(Math.random() * (enemyTypes.length - 1)); // Exclude guru
                        } while (typeIndex === lastEnemyTypeIndex);
                    } else {
                        return; // Can't spawn any more enemies this round
                    }
                    
                    lastEnemyTypeIndex = typeIndex;
                    const enemyType = enemyTypes[typeIndex];
                    
                    // Try multiple times to find a clear position
                    for (let attempts = 0; attempts < 10; attempts++) {
                        const x = roadLeft + enemyType.width/2 + Math.random() * (roadWidth - enemyType.width);
                        const y = -50;
                        
                        if (isPositionClear(x, y, enemyType.width, enemyType.height)) {
                            const enemy = {
                                x: x,
                                y: y,
                                speed: enemyType.speed * (1 + (currentRound - 1) * 0.1), // Reduced from 0.2 to 0.1 - increase enemy speed by 10% each round
                                type: enemyType.type,
                                width: enemyType.width,
                                height: enemyType.height,
                                isDeadly: enemyType.isDeadly || false
                            };
                            enemies.push(enemy);
                            break;
                        }
                    }
                }
            }
            
            // Update enemy characters
            function updateEnemies() {
                for (let i = enemies.length - 1; i >= 0; i--) {
                    enemies[i].y += enemies[i].speed;
                    
                    // Keep enemies within road boundaries
                    if (enemies[i].x < roadLeft + enemies[i].width/2) {
                        enemies[i].x = roadLeft + enemies[i].width/2;
                    }
                    if (enemies[i].x > roadLeft + roadWidth - enemies[i].width/2) {
                        enemies[i].x = roadLeft + roadWidth - enemies[i].width/2;
                    }
                    
                    // Check collision with player
                    if (
                        enemies[i].y > player.y - player.height/2 && 
                        enemies[i].y < player.y + player.height/2 && 
                        enemies[i].x > player.x - player.width/2 && 
                        enemies[i].x < player.x + player.width/2
                    ) {
                        // Check if it's the deadly guru character
                        if (enemies[i].isDeadly) {
                            // Game over immediately if colliding with guru
                            gameState = 'gameOver';
                            gameOverReason = "Guru caught you!";
                            stopBackgroundMusic(); // Stop music when game ends
                            enemies.splice(i, 1);
                            continue;
                        } else {
                            // Player hit regular enemy - different damage for different enemies
                            let damage = 20; // Default damage
                            if (enemies[i].type === 'raviAnna') {
                                damage = 30; // Ravi Anna does more damage
                            }
                            player.energy = Math.max(0, player.energy - damage);
                            player.isHit = true;
                            
                            // Reset isHit after a short delay
                            setTimeout(() => { player.isHit = false; }, 1000);
                            
                            enemies.splice(i, 1);
                            continue;
                        }
                    }
                    
                    // Remove if off screen
                    if (enemies[i].y > canvas.height + 50) {
                        enemies.splice(i, 1);
                    }
                }
            }
            
            // LED Dotted Font Function
            function drawLEDText(text, x, y, size, flashOn) {
                const dotSize = size / 8; // Size of each LED dot
                const spacing = size / 6; // Spacing between dots
                const letterSpacing = size * 0.8; // Spacing between letters
                
                // LED colors
                const onColor = flashOn ? '#00FF00' : '#004400';
                const glowColor = flashOn ? '#88FF88' : '#002200';
                
                let currentX = x - (text.length * letterSpacing) / 2; // Center the text
                
                for (let i = 0; i < text.length; i++) {
                    const char = text[i];
                    if (char === ' ') {
                        currentX += letterSpacing;
                        continue;
                    }
                    
                    // Draw LED dots for each character in a 7x5 grid pattern
                    drawLEDCharacter(char, currentX, y, dotSize, spacing, onColor, glowColor, flashOn);
                    currentX += letterSpacing;
                }
            }
            
            function drawLEDCharacter(char, x, y, dotSize, spacing, color, glowColor, flashOn) {
                // Define 7x5 LED patterns for each character
                const patterns = {
                    'T': [
                        [1,1,1,1,1],
                        [0,0,1,0,0],
                        [0,0,1,0,0],
                        [0,0,1,0,0],
                        [0,0,1,0,0],
                        [0,0,1,0,0],
                        [0,0,1,0,0]
                    ],
                    'H': [
                        [1,0,0,0,1],
                        [1,0,0,0,1],
                        [1,0,0,0,1],
                        [1,1,1,1,1],
                        [1,0,0,0,1],
                        [1,0,0,0,1],
                        [1,0,0,0,1]
                    ],
                    'E': [
                        [1,1,1,1,1],
                        [1,0,0,0,0],
                        [1,0,0,0,0],
                        [1,1,1,1,0],
                        [1,0,0,0,0],
                        [1,0,0,0,0],
                        [1,1,1,1,1]
                    ],
                    'B': [
                        [1,1,1,1,0],
                        [1,0,0,0,1],
                        [1,0,0,0,1],
                        [1,1,1,1,0],
                        [1,0,0,0,1],
                        [1,0,0,0,1],
                        [1,1,1,1,0]
                    ],
                    'A': [
                        [0,1,1,1,0],
                        [1,0,0,0,1],
                        [1,0,0,0,1],
                        [1,1,1,1,1],
                        [1,0,0,0,1],
                        [1,0,0,0,1],
                        [1,0,0,0,1]
                    ],
                    'V': [
                        [1,0,0,0,1],
                        [1,0,0,0,1],
                        [1,0,0,0,1],
                        [1,0,0,0,1],
                        [1,0,0,0,1],
                        [0,1,0,1,0],
                        [0,0,1,0,0]
                    ],
                    'G': [
                        [0,1,1,1,1],
                        [1,0,0,0,0],
                        [1,0,0,0,0],
                        [1,0,1,1,1],
                        [1,0,0,0,1],
                        [1,0,0,0,1],
                        [0,1,1,1,0]
                    ],
                    'M': [
                        [1,0,0,0,1],
                        [1,1,0,1,1],
                        [1,0,1,0,1],
                        [1,0,0,0,1],
                        [1,0,0,0,1],
                        [1,0,0,0,1],
                        [1,0,0,0,1]
                    ]
                };
                
                const pattern = patterns[char] || patterns['A']; // Default to A if character not found
                
                for (let row = 0; row < pattern.length; row++) {
                    for (let col = 0; col < pattern[row].length; col++) {
                        if (pattern[row][col] === 1) {
                            const dotX = x + col * spacing;
                            const dotY = y + row * spacing;
                            
                            // Draw glow effect when flashing
                            if (flashOn) {
                                ctx.shadowColor = glowColor;
                                ctx.shadowBlur = dotSize;
                            }
                            
                            ctx.fillStyle = color;
                            ctx.beginPath();
                            ctx.arc(dotX, dotY, dotSize / 2, 0, Math.PI * 2);
                            ctx.fill();
                            
                            // Reset shadow
                            ctx.shadowBlur = 0;
                        }
                    }
                }
            }
            
            // Draw start screen
            function drawStartScreen() {
                // Dark tinted background
                const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                gradient.addColorStop(0, 'rgba(0, 0, 0, 0.8)'); // Dark black tint
                gradient.addColorStop(1, 'rgba(20, 20, 20, 0.9)'); // Darker bottom
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Calculate positions
                const centerX = canvas.width / 2;
                let currentY = canvas.height * 0.25; // Start from 25% down
                
                ctx.textAlign = 'center';
                
                // Flashing/glowing effect for title
                const flashOn = Math.floor(Date.now() / 600) % 2 === 0; // Flash every 600ms
                const glowIntensity = flashOn ? 20 : 5;
                
                // "THE" - Smaller than BHAAVA
                ctx.fillStyle = '#FFFFFF'; // White
                ctx.font = "40px 'Press Start 2P', monospace"; // Reduced from 48px to 40px
                ctx.shadowColor = flashOn ? '#00FFFF' : '#FFFFFF'; // Cyan glow when flashing
                ctx.shadowBlur = glowIntensity;
                ctx.fillText('THE', centerX, currentY);
                
                currentY += 70; // Spacing above BHAAVA
                
                // "BHAAVA" - Largest, properly centered without extra spaces
                ctx.fillStyle = '#FFFFFF'; // White
                ctx.font = "64px 'Press Start 2P', monospace";
                ctx.shadowColor = flashOn ? '#00FFFF' : '#FFFFFF'; // Cyan glow when flashing
                ctx.shadowBlur = glowIntensity;
                ctx.fillText('BHAAVA', centerX, currentY); // Removed extra spaces for proper centering
                
                currentY += 70; // Equal spacing below BHAAVA (same as above)
                
                // "GAME" - Smaller than BHAAVA, same as THE
                ctx.fillStyle = '#FFFFFF'; // White
                ctx.font = "40px 'Press Start 2P', monospace"; // Reduced from 48px to 40px to match THE
                ctx.shadowColor = flashOn ? '#00FFFF' : '#FFFFFF'; // Cyan glow when flashing
                ctx.shadowBlur = glowIntensity;
                ctx.fillText('GAME', centerX, currentY);
                
                // Reset shadow for other text
                ctx.shadowBlur = 0;
                
                currentY += 100; // Larger break
                
                // Subtitle - Help text (broken into multiple lines for better fit)
                ctx.fillStyle = '#CCCCCC'; // Light gray
                ctx.font = "14px 'Press Start 2P', cursive"; // Reduced font size to fit screen
                ctx.fillText('Help Bhaava navigate', centerX, currentY);
                
                currentY += 28; // Line break
                
                ctx.fillText('Naveena\'s Beegru Oota !', centerX, currentY);
                
                currentY += 70; // Line break
                
                // Tap to start
                ctx.fillStyle = '#AAAAAA'; // Medium gray
                ctx.font = "14px 'Press Start 2P', cursive"; // Increased from 10px to 14px
                ctx.fillText('Tap to Start Play', centerX, currentY);
                
                currentY += 50; // First line break
                
                currentY += 30; // Second line break
                
                // Warning text in red - same size as beegru line
                ctx.fillStyle = '#FF0000'; // Red
                ctx.font = "14px 'Press Start 2P', cursive"; // Same as beegru line (14px)
                ctx.fillText('PS: Beware of Guruji !', centerX, currentY);
            }
            
            // Draw game over screen
            function drawGameOverScreen() {
                // Create lighter gradient background
                const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                gradient.addColorStop(0, 'rgba(20, 20, 50, 0.85)'); // Lighter
                gradient.addColorStop(1, 'rgba(15, 15, 40, 0.90)'); // Lighter
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Set text alignment for centered text
                ctx.textAlign = 'center';
                
                // Calculate positions for proper spacing
                const centerX = canvas.width / 2;
                let currentY = canvas.height / 2 - 120; // Start higher up
                
                // Flashing and glow effect variables (same as home page)
                const time = Date.now();
                const flashOn = Math.floor(time / 400) % 2 === 0; // Flash every 400ms
                const glowIntensity = 15 + 10 * Math.sin(time / 300); // Pulsing glow
                
                // "BHAAVA" - Small (40px)
                ctx.fillStyle = '#FFFFFF'; // White
                ctx.font = "40px 'Press Start 2P', monospace";
                ctx.shadowColor = flashOn ? '#00FFFF' : '#FFFFFF'; // Cyan glow when flashing
                ctx.shadowBlur = glowIntensity;
                ctx.fillText('BHAAVA', centerX, currentY);
                
                currentY += 70; // Equal spacing
                
                // "PUDCHA" - Biggest (64px)
                ctx.fillStyle = '#FFFFFF'; // White
                ctx.font = "64px 'Press Start 2P', monospace";
                ctx.shadowColor = flashOn ? '#00FFFF' : '#FFFFFF'; // Cyan glow when flashing
                ctx.shadowBlur = glowIntensity;
                ctx.fillText('PUDCHA', centerX, currentY);
                
                currentY += 70; // Equal spacing
                
                // "MARRE!" - Small (40px)
                ctx.fillStyle = '#FFFFFF'; // White
                ctx.font = "40px 'Press Start 2P', monospace";
                ctx.shadowColor = flashOn ? '#00FFFF' : '#FFFFFF'; // Cyan glow when flashing
                ctx.shadowBlur = glowIntensity;
                ctx.fillText('MARRE!', centerX, currentY);
                
                // Reset shadow for score and other text
                ctx.shadowBlur = 0;
                
                currentY += 80; // Larger break before score
                
                // "Your Score:" label
                ctx.fillStyle = '#FFFFFF';
                ctx.font = "18px 'Press Start 2P', monospace";
                ctx.fillText('Your Score:', centerX, currentY);
                
                currentY += 40; // Space between label and score
                
                // Score value in bright green
                ctx.fillStyle = '#00FF00'; // Bright green like an LED
                ctx.font = "32px 'Press Start 2P', monospace";
                ctx.fillText(`${score}`, centerX, currentY);
                
                currentY += 60; // Space before restart prompt
                
                // "Tap to Start Play" without blinking effect
                ctx.fillStyle = '#FFFFFF';
                ctx.font = "18px 'Press Start 2P', monospace";
                ctx.fillText('Tap to Start Play', centerX, currentY);
            }
            
            // Handle keyboard input
            function handleKeyDown(e) {
                if (gameState === 'playing') {
                    if (e.key === 'ArrowLeft') {
                        player.direction = -1;
                    } else if (e.key === 'ArrowRight') {
                        player.direction = 1;
                    }
                }
            }
            
            function handleKeyUp(e) {
                if (e.key === 'ArrowLeft' && player.direction === -1) {
                    player.direction = 0;
                } else if (e.key === 'ArrowRight' && player.direction === 1) {
                    player.direction = 0;
                }
            }
            
            // Handle touch input
            function setupMobileControls() {
                const leftBtn = document.getElementById('leftBtn');
                const rightBtn = document.getElementById('rightBtn');
                
                // Show buttons for mobile
                if (isMobile) {
                    leftBtn.style.display = 'block';
                    rightBtn.style.display = 'block';
                }
                
                leftBtn.addEventListener('touchstart', function(e) {
                    e.preventDefault();
                    if (gameState === 'playing') {
                        player.direction = -1;
                    }
                });
                
                rightBtn.addEventListener('touchstart', function(e) {
                    e.preventDefault();
                    if (gameState === 'playing') {
                        player.direction = 1;
                    }
                });
                
                leftBtn.addEventListener('touchend', function(e) {
                    e.preventDefault();
                    if (player.direction === -1) {
                        player.direction = 0;
                    }
                });
                
                rightBtn.addEventListener('touchend', function(e) {
                    e.preventDefault();
                    if (player.direction === 1) {
                        player.direction = 0;
                    }
                });
            }
            
            // Start or restart the game
            function startGame() {
                if (gameState === 'start' || gameState === 'gameOver') {
                    // Reset game state
                    gameState = 'playing';
                    player.energy = 100;
                    score = 0;
                    
                    // Reset round system
                    currentRound = 1;
                    roundStartTime = 0;
                    guruSpawnedThisRound = 0;
                    showRoundTransition = false;
                    roundTransitionStartTime = 0;
                    
                    // Clear arrays
                    alcohols.length = 0;
                    leaves.length = 0;
                    enemies.length = 0;
                    
                    // Start background music if enabled
                    playBackgroundMusic();
                }
            }
            
            // Update the village objects with continuous upward movement like the poles
            function updateVillageObjects() {
                // Define the speed at which objects move upward (slower than poles for parallax effect)
                const moveSpeed = 0.8; // Slightly faster speed to match the increased distances
                
                // Define fixed positions for the three visible positions with increased spacing
                // These are percentages of canvas height from the top
                const positions = [
                    canvas.height * 1.6,    // Far bottom - well below screen
                    canvas.height * 1.0,    // Lower visible position (bottom of screen)
                    canvas.height * 0.3,    // Middle visible position (much more space from bottom)
                    canvas.height * -0.4    // Top position (far above screen to ensure big gaps)
                ];
                
                // Get the height of the object's image for better reset position
                const getObjectHeight = (obj) => {
                    const img = images[obj.type];
                    return img ? img.height * obj.scale : 100;
                };
                
                // Update each object's position
                villageObjects.forEach((obj, index) => {
                    // Save initial X position if not already saved (for horizontal position)
                    if (!obj.initialX) {
                        obj.initialX = obj.x;
                    }
                    
                    // Move object up by moveSpeed
                    obj.y -= moveSpeed;
                    
                    // Get object height for proper reset point
                    const objHeight = getObjectHeight(obj);
                    
                    // If object moves completely above the screen, reset to below the screen
                    if (obj.y < -objHeight) { // Completely above top of screen
                        obj.y = canvas.height * 1.6; // Reset to the far bottom position
                        
                        // Make sure objects maintain proper spacing when they reappear
                        // Check for any objects already in the bottom area on the same side
                        const bottomObjects = villageObjects.filter(o => 
                            o !== obj && o.side === obj.side && 
                            o.y > canvas.height && o.y < canvas.height * 2);
                            
                        if (bottomObjects.length > 0) {
                            // If there's already an object in the bottom area on the same side, move this one further down
                            obj.y = canvas.height * 2.0; // Place even further below screen
                        }
                    }
                    
                    // Small horizontal sway for visual interest
                    const frequencyOffset = 60 + (index * 15); // Different frequency for each object
                    const horizontalOffset = Math.cos(animationFrame / frequencyOffset) * 0.5; // Subtle left/right movement
                    obj.x = obj.initialX + horizontalOffset;
                    
                    // Update initial Y for reference (used by drawing code)
                    obj.initialY = obj.y;
                });
            }
            
            // Main game loop
            function gameLoop(timestamp) {
                // Calculate delta time
                const deltaTime = timestamp - lastTime;
                lastTime = timestamp;
                
                // Hide all GIF elements first - only show the ones needed
                hideAllGifs();
                
                // Clear the canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Increment animation frame
                animationFrame++;
                
                // Update light flash timer and state for village fair lights
                lightFlashTimer += deltaTime;
                if (lightFlashTimer > 800) { // Slower flashing (800ms) for a more pleasant rhythm
                    lightFlashTimer = 0;
                    lightState = !lightState;
                }
                
                // Always update village objects for the subtle animation
                updateVillageObjects();
                
                // Draw the game scene
                drawScene();
                
                if (gameState === 'playing') {
                    // Update round progression
                    updateRound(timestamp);
                    
                    // Update game objects
                    updatePlayer(deltaTime);
                    
                    // Spawn and update obstacles and pickups
                    spawnAlcohol();
                    updateAlcohols();
                    
                    spawnLeaves();
                    updateLeaves();
                    
                    spawnEnemies();
                    updateEnemies();
                    
                    // Draw game objects
                    drawPlayer();
                    
                    // Draw alcohols
                    alcohols.forEach(alcohol => {
                        drawAlcohol(alcohol);
                    });
                    
                    // Draw leaves
                    leaves.forEach(leaf => {
                        drawLeaf(leaf);
                    });
                    
                    // Draw enemies
                    enemies.forEach(enemy => {
                        drawEnemy(enemy);
                    });
                    
                    // Draw UI
                    drawEnergyBar();
                } else if (gameState === 'start') {
                    drawStartScreen();
                } else if (gameState === 'gameOver') {
                    drawGameOverScreen();
                }
                
                requestAnimationFrame(gameLoop);
            }
            
            // Event listeners
            window.addEventListener('keydown', handleKeyDown);
            window.addEventListener('keyup', handleKeyUp);
            
            // Click/tap to start or restart game
            canvas.addEventListener('click', startGame);
            canvas.addEventListener('touchstart', function(e) {
                e.preventDefault(); // Prevent double-firing of events
                startGame();
            });
            
            // Set up mobile controls
            setupMobileControls();
            
            // Handle window resize
            window.addEventListener('resize', resizeCanvas);
            
            // Initialize game
            init();
        });
    </script>
</body>
</html>
